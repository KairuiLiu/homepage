---
title: 计算机网络(自顶向下)笔记
date: 2021-7-4 00:00:00
toc: true
description: 计算机网络(自顶向下第七版)笔记,主讲:中科大郑烇,视频来自B站:BV1JV411t7ow
categories:
  - [计算机理论,计算机网络]
tags:
  - 计算机理论
  - 计算机网络
  - 笔记
---

本书是自顶向下进行的, 在第一章概述计算机网络的层次结构,从第二章开始从上到下一章介绍一层(大致), 最后是移动互联网/网络安全的内容

计算机网络中的每一层都具有一定的功能, 通过层间接口向上层提供服务, 通过调用下层接口实现一定的功能.

**每一层的学习方式**

- 原理
  - 功能
  - 向上层服务
  - 向下层调用
- 应用(常见协议)
  - 协议的时序: 确定通信双方"讲话的次序"，定义了速度, 排序等。
  - 协议的语法: 确定通信双方"如何讲话"，定义了数据格式，编码和信号电平等。
  - 协议的语义: 确定通信双方"讲什么"，定义了用于协调同步和差错处理的控制信息。

## 概论

### 什么是互联网

互联网是很多的网络相互连接构成的网络的网络, 不同的网络处在互联网中不同的层次, 网络是边与点的集合

**互联网的构成**

- 节点
  - 主机(端系统)及其上运行的应用程序
  - 路由器、交换机等网络交换设备
- 边(通信链路)
  - 接入网链路:主机连接到互联网的链路
  - 主干链路:路由器间的链路
  - 传输速率就是带宽(bps)
- 协议
  - 支持互联网工作的标准
  - 对等层网络在通信的时候应该遵守的标准, 包含语法, 语义, 时序
  - Internet网协议就是以TCP/IP协议为主的协议组

**互联网的服务**

- 分布式的应用进程
- 用于通信基础设施(通过Socket API提供服务有面向连接的与无连接的服务)

**网络的结构**

- 网络的边缘: 包括主机与应用程序
- 网络的核心: 互联的路由器与网络中的子网
- 接入网: 网络边缘与网络核心连接的有线或者无线通信链路

### 网络的边缘

网络边缘有运行着分布式应用的主机, 提供CS/P2P两种**通信模式**

- CS模式: 服务器客户端模式, 客户端主动发起请求, 服务端响应, 数据存储在服务端, 存在单点故障与可靠性的问题(请求强度增大, 性能断崖式下降)
- P2P模式: 没有专门的服务器, 每个节点既是客户端也是服务器

**连接方式**

- 面向连接: 在通信之前先打招呼, 服务端准备资源, 建立连接, 在**通信两段**保持连接
- 有连接: 在面向连接的基础上让**通信链路上的每个节点**都维护通信的状态
- 无连接: 不打招呼直接发送请求.

**面向连接的服务**: 以TCP连接为代表, 具有

- 可靠的, 有序的: 支持确认与重传(不重复, 不遗漏, 不出错, 不失序)
- 流量控制: 发送方发送的数据包不会淹没接收方
- 拥塞控制: 网络拥塞的时候降低传输速度
- 用于http/ftp/telnet/smtp应用

**无连接的服务**: UPD用户数据报协议

- 不可靠
- 速度快
- 无流量控制拥塞控制
- 用于音视频多媒体应用

### 网络的核心

网络的核心是路由器连接的网状网

**网络核心的关键功能**

- 转发: 局部行为, 将分组从输入链路转移到输出链路
- 路由: 规划分组从源到目标的路径

**网络核心数据通信方式**

- **电路交换**: 为每个连接预留一条道路, 当两者在通信的时候, 他们经过的链路不可被其他人使用, 注意: 不是说两者之间直接拉一根网线, 这与电话链接是类似的, 是通过建立一条虚电路在网络中找到一条可以使用的链路并独享
- **分组交换**: 
  - 将要传输的数据分成一个个分组
  - 单个分组一次性从一个路由器转发到另一个路由器
  - 每个分组在一次转发的时候全速进行

**电路交换**

- 数据被一口气从发送端连接到接收端, 一旦连接建立, 即使没有数据交换, 在没有结束通信之前链路资源仍然不会释放

- 链路资源独享, 保证了连接的性能

- 线路分片技术

  将一个线路分成多个小片, 实现在一条线路上跑同时跑多个数据

  - FDMA: 频分复用技术, 不同的数据包使用不同的频率叠加在一起发送, 到接收端再过滤
  - TDMA: 时分复用技术, 不同的数据包以不同相位同周期发送
  - WDMA: 波分复用技术(光通信)
  
- 线路交换不适合计算机的通信

  - 连接建立需要较长的时间(在整个链路上建立一个虚电路进行通讯)
  - 计算机之间的通信具有突发性, 使用线路交换会浪费较多的资源
  - 可靠性不好

**分组交换**

- 主机与主机的通信以**分组**为单位**存储转发**
- 分组到达某一个节点之后, 分组转发设备要将数据存下, 再转发
- 节点之间的通信链路不再使用分片技术, 分组全速通过链路
- 实现了传输过程中只占用了一部分链路而不是整条链路, 实现了线路的共享性(一段连续时间给这个用, 一段连续时间给另一个人用, 看起来很像时分多路复用, 但是划分方式没有固定的模式, 我们称之为统计多路复用)
- 由于需要进行存储, 所以存在存储的延迟和排队延迟

**分组交换时延计算**

- 时延: 是数据(一个报文或分组，甚至比特)从网络或链路的一段传送到另一端所需要的时间

- **传输延迟**$d_{trans}$ 是从发送数据帧的第一个比特算起, 到该帧的最后一个比特发送完毕所需的时间, 网卡把数据包放在链路上的时间

  传输时延=分组长度L(b) /链路带宽R(bps)

- **传播延迟**$d_{prop}$: 电磁波在信道中需要传播一定的距离而花费的时间, 
  传播时延=物理链路长度d(m)/电磁波在信道上的传播速率s(m/s)

- **处理延迟**$d_{proc}$:: 主机或路由器处理所收到的分组(查路由表, 检错)的时间

- **排队延迟**$d_{queue}$: 分组在输入队列中排队等待处理，在输出队列中等待转发，就形成了排队时延。[随机的, 如果不巧队列满了, 数据包就会被丢弃]

- **总延迟**
  $$
  d_{nodal}=d_{proc}+d_{queue}+d_{trans}+d_{prop}
  $$

- 发送时延是发送方将数据从网卡放在链路上的延迟

  接收时延接收方收到数据从链路装载在网卡的延迟

  两者是一边发送, 一边接收的, 不是发送发发完接收方才去接收的, 所以**发送与接收时延只能计算一次**

  进行这类计算的时候最好画一个时延图

**两者比较**: 对于同一带宽链路, 分组交换支持的用户数目更多, 例如

有一条1Mbps的通信链路, 假设活跃用户需要的带宽是100Kbps, 用户只有$p=10\%$的时间是活跃的(因为计算机通信具有很强的突发性)

- 假设采用线路交换最多支持的用户数目为$N$
  $$
  \begin{align}
  N&=\frac{1Mbps}{100Kbps}\\
  &=10
  \end{align}
  $$

- 假设采用分组交换支持的用户数目$N$

  这$N$人中有**小于等于**$n$人活跃的概率是
  $$
  \sum_{i=0}^{n}C^{i}_{35}p^i(1-p)^{N-i}
  $$
  也就是说这$N$人中有**大于**$n$人活跃的概率是
  $$
  1-\sum_{i=0}^{n}C^{i}_{35}p^i(1-p)^{N-i}
  $$
  当有$N=35$个用户, $n=9$人以上活动的概率是0.0004, 这里选择9人是因为: 如果线路满载, 理论可以提供的用户数是10, 但是如果真的有10人在用, 由于分组交换存在分组延迟排队等原因, 队列会越排越长, 最后网络崩溃, 所以$n$只能为9

  相当于说有在分组交换时, 有0.04%的概率无法满足使用, 但是我们还有缓存队列来应付这0.04%的突发的情况

**让分组交换像电路交换一样工作**

有很多服务需要高实时性(例如音视频服务), 我们想让网络具有线路交换的特性. 有两种实现方式

- 数据报网络(UDP): 在请求与响应传输的时候不需要握手, 直接传输(数据报包含了目标主机全部信息), 路由器只负责转发, 不维护主机之间的状态
- 虚电路: 使用信令在途径的所有交换设备上建立一个虚电路表, 写明要吧数据数据包转发到哪里(而不是查询路由表)

### 接入网和物理媒体

网络边缘的端系统通过接入网将自己接入网络核心

**使用modem接入**

利用原有的电话网, 将上网的数据通过调制解调器(modem)调制为电话线上的4KHz的语音频段信号(同时还实现了多路复用), 局端将其中的数据解调出来.

但是网速只有56Kbps, 不能同时打电话与上网

**DSL接入**

与modem类似, 仍然使用电话网, 使用4KHz的音频信号以上的信号段, 将一部分频段专门用于上传, 一部分专门用于下载(虽然打电话只用到了4KHz, 但是电话线也不是不可以传输高于4KHz的信息)

**线缆网络**

对有限电视信号线进行双向改造, 采用频分复用技术, 共享带宽(在数据链路层会介绍)

**电缆网络**

利用电网进行数据传输

**Ethernet**

企业一般使用Ethernet接入互联网, Ethernet可以理解为是可能不遵守Internet协议的网络. 或者说Ethernet是一个类, Internet是一个实例. 企业内网直接连接到外网交换机上

**通过移动互联的方式接入**

可以通过无线局域网**WLAN**, 移动网络接入互联网, 卫星通信

**常见的接入媒介**

- 导引型媒体:
  信号沿着固体媒介被导引:同轴电缆、光纤、 双绞线
- 非导引型媒体:
  开放的空间传输电磁波或者光信号,在电磁或者光信号中承载数据

### Internet结构与ISP

前面我们将互联网划分为主机与链路, 主机节点构成的子系统叫网络的边缘, 交换节点与链路构成了网络的核心, 通过接入网将两者连起来

还可以将关系比较密集的节点划分成一个网络, 例如可以把一个ISP(互联网服务提供商)的网络划分为一个子网, ISP的网络互相连接构成互联网

- 端系统通过接入ISP(比如所在的大学, 所在的住宅楼)连接到互联网, 
- ISP之间相互通信实现互联
- ICP(互联网内容提供商)也会构建自己的网络并将网络接入离数据中心机房很近的ISP的网络

### 分组延迟/丢失/吞吐量

网络核心有线路交换和分组交换的方式, 分组交换的共享性比较好, 但是存在更多的延迟与分组的丢弃

**分组的丢失与延迟**

当路由器上的分组要通过链路, 链路上有其他分组的时候, 分组需要进行排队等待, 这造成了分组**排队延迟**, 如果分组到达时队列已满, 分组会被丢弃. 队列不需要很大, 分组在经过过长时间的等待即使没有丢失也已经变得无意义了

**四种延迟**(复制前面)

- **传输延迟**$d_{trans}$ 是从发送数据帧的第一个比特算起, 到该帧的最后一个比特发送完毕所需的时间, 网卡把数据包放在链路上的时间

  传输时延=分组长度L(b) /链路带宽R(bps)

- **传播延迟**$d_{prop}$: 电磁波在信道中需要传播一定的距离而花费的时间, 
  传播时延=物理链路长度d(m)/电磁波在信道上的传播速率s(m/s)

- **处理延迟**$d_{proc}$:: 主机或路由器处理所收到的分组(查路由表, 检错)的时间

- **排队延迟**$d_{queue}$: 分组在输入队列中排队等待处理，在输出队列中等待转发，就形成了排队时延。[随机的, 如果不巧队列满了, 数据包就会被丢弃]

- **总延迟**
  $$
  d_{nodal}=d_{proc}+d_{queue}+d_{trans}+d_{prop}
  $$

**排队延迟**

排队延迟取决于流量强度$I$, 流量强度有$I=\frac{L\alpha}{R}$, $R$是链路传输速率, $L$是分组长度, $\alpha$是每秒需要放出的分组数, $I$的意义就是流量到达的速率是传输速率的几倍, 流量强度接近于1, 排队延迟接近无穷大

![排队延迟](./1-1.png)

**吞吐量**

单位时间内源主机到目标主机传输的有效比特量, 有瞬间吞吐量和平均吞吐量

吞吐量取决于数据链路中速率最低的链路, 也叫瓶颈链路

在实际网络中, 瓶颈链路的速率可能并不低, 但是共享人数过多造成速率较低

### 协议层次与服务模型

网络是一个复杂的系统, 通过分层的方式实现, 一个层次可以通过层间接口调用他的下层的服务实现一个功能. 将网络复杂的功能分解成若干功能分明的层次

- 一个层可以调用下层提供的服务
- 对等层的模块之间通过**协议**交换控制信息
- 一个层可以通过下层提供的信息, 结合对等层交换获得的信息实现自己的功能, 从而为上层服务
- 一个层的一部分功能(服务)可以通过层间接口被上层调用

**术语**

- **服务**

  - **服务**: 低层实体向上层实体提供他们通信能力(功能), 例如顺丰提供物流业务
  - **服务用户**: 某层提供的服务被上层的服务用户使用, 也就是下层服务的调用者, 例如用户调用顺丰的服务
  - **SAP服务访问点**: 层之间的点, 用于区分不同的服务用户, 例如传输层的服务访问点是端口, 例如顺丰通过寄件地址上门取件
  - **原语**: 上层使用下层用户的形式, 例如Socket API中的函数就是原语, 例如上层关闭链接, 我使用了顺丰服务的代收货款这一功能(原语), 更通俗的理解就是函数调用

- **服务的类型**

  - **面向连接的服务**: 两个对等层在通信之前要先进行连接, 为通信做准备的服务
  - **无连接的服务**: 两个对等层在通信之间不需要建立连接, 不需要预备资源的服务

- **服务与协议的区别**

  - 服务是垂直的层与层之间的关系, 在一个系统内部, 相邻的两个实体在SAP上, 上层使用原语调用下层的服务
  - 协议是对等层的实体在通讯时的规则

- **数据单元DU**

  ![DU](./1-2.png)

  在这个图中,  我们假设我们在第n层, 上层是n+1层

  - **SAP服务访问点**: 存在于层间服务之间, 层间有多个SAP, 每个SAP具有唯一识别地址
  - **SDU服务数据单元**: 上层(n+1)交给我, 要求我进行传输的数据单元
  - **ICI接口控制信息**: 本层在SDU前面加入的控制信息(用于可以**顺利通过与下层的SAP**)
  - **IDU接口数据单元**: 本层中ICI与SDU的组合, 用于向下层传递SDU
  - **PCI协议控制信息**: 本层在SDU前面加入控制信息用于实现本层功能(也写成Header)
  - **PDU协议数据单元**: 本层的PCI与上层的SDU组合形成PDU, 用于对等层的通信
  - 注意: ICI只是上层用于通告SAP的, 与SDU组成产生IDU, ICI在通过后可能被丢弃, PIC是本层的控制信息头部, 用来与SDU结合产生PDU
  - SDU在传输的时候, 可能是一个SDU完整的传输, 如果SDU过大则会切片传输, 如果SDU过小则会组合传输

- **PDU的不同名称**

  - 在应用层叫应用报文 Message
  - 在传输层叫报文段 Segment, TCP段/UDP数据报
  - 在网络层叫分组 Packet, 如果是无连接的也可以叫数据报 Datagram
  - 在链路层叫帧 Frame
  - 在物理层叫位 Bit

**分层带来的特性**

- 概念化: 方便描述网络组件的关系
- 结构化: 易于维护与升级
- 低效化: 层之间的交互会降低效率

**互联网协议栈(5层)**

- 物理层: 将上层交来的帧转化成物理信号
- 链路层: 在相邻两点传输以帧为单位的数据**[点到点]**
- 网络层: 在主机之间传输以分组为单位的端到端的数据**[主机到主机]**
- 传输层: 实现主机与主机之间的(可靠的)数据传输**[进程到进程]**
- 应用层: 实现应用报文与应用报文之间的交互**[应用到应用]**

**ISO/OSI参考模型**

比五层协议多两层

- 表示层: 允许应用解释传输的数据, e.g., 加密,压缩,机器相关的表示转换
- 会话层: 数据交换的同步,检查点,恢复

**封装与解封装**

源主机向目标主机发送请求, 在逻辑上是直接通信, 实际上需要进行多次的存储转发, 在转发时, 遇到交换机(二层交换机)要进行解封装到数据链路层进行转发与重封装, 遇到路由器(三层路由器)要进行解封装到网络层进行转发与重封装

## 应用层

### 应用层原理

**网络应用的体系结构**

- C/S架构: 客户服务器模式, 服务器一直运行, 守护在特定端口, 客户端请求服务器响应, 资源在服务器, 可扩展性差
- P2P模式: 节点既请求别人的服务, 自己也作为服务器, 参与的主机之间可以间歇性连接, 改变IP等
- 混合模式

**应用进程需要解决问题**

- 标识与寻址: 用于服务器找到用户
- 下层提供的服务模型与使用形式
- 如何使用下层服务完成报文交换

**编址与寻址**

- 地址: 用户的主机IP, 使用的下层协议TCP/UDP, 进程运行在端口上(TCP与UDP可以使用相同的端口号, TCP与UDP可以同时使用相同的端口号, 但是TCP中一个端口号只能用一次)
- 寻址, 穿过SAP需要的信息: 
  - 要传输的内容: 应用层Message
  - 谁发的: 本机的IP+TCP/UDP端口
  - 发给谁: 对方的IP+TCP/UDP端口

- Socket

  我们不能每次传输报文的时候都发送双方IP与端口号, 这样会消耗很多资源, 可以将这四个值映射为一个Socket值(一个整数), 第一次通信下层返回一个Socket值, 如果之后仍然是和原来的目标实体进行连接, 就直接向下层Socket值

  - TCP由于需要握手(面向连接), Socket是代表源IP, 目标IP, 源端口, 目标端口的一个双方的标识, 在传输数据的时候传输**数据, Socket**
  - UDP由于不需要握手(无连接), Socket只是代表源IP, 源端口的一个本地标识, 应用层在发送UDP请求的时候需要**传输消息, Socket, 对方的IP与对方UDP端口**

  Socket使得连接便于管理, 减少了与传输层连接的时传输的数据量

  可以这么理解, 我使用顺丰寄快递, 每次都要写寄件人收件人信息就很烦, 于是我们可以用一个数字代表收寄信息

  - 对于我经常联系(TCP)的朋友, 我可以把我的和对方的信息全部打包成一个数字, 以后写收寄人的时候直接写一个数字就可以了
  - 对于我偶尔联系(UDP)的朋友, 我可以把我的寄件地址打包成一个数字, 以后我的信息就可以用数字填写了, 收件人信息还要手动填写

 **应用层需要传输层提供的服务模型**

- 数据丢失率
- 延迟
- 吞吐量
- 安全性

**传输层提供的服务**

- TCP服务
  - 可靠的
  - 具有流量控制, 拥塞控制
  - 尽力而为的
  - 面向连接的
- UDP服务
  -  不可靠数据传输
  - 不提供可靠流量控制、拥塞控制、时间、带宽保证、建立连接

- UDP的优点
  - 能够区分不同的进程,而 IP服务不能
  - 在IP提供的主机到主机端到端功能的基础上,区分了主机的应用进程
  - 无需建立连接,省去了建立连接时间,适合事务性的应用
  - 不做可靠性的检查工作,例如检错重发,适合那些对实时性要求比较高而对正确性要求不高的应用
  - 节约了为了实现可靠性(准确性、保序等)付出的时间代价(检错重发)
  - 没有拥塞控制和流量控制,应用能够按照设定的速度发送数据
  
    而在TCP上面的应用,应用发送数据的速度和主机向网络发送的实际速度是不一致的,因为有流量控制和拥塞控制
  
- 安全性
  - TCP与UDP都没有加密, 明文传输
  - SSL: 在TCP上面实现加密TCP连接, 保证了私密性, 数据完整性, 提供端到端的鉴别

### Web应用与http协议

**术语**

- **Web的对象**: Web页面是由一些对象构成的, 对象一般包括图像, 声音...

- **基本HTML文件**: Web页包含了一个基本的HTML文件, 这个文件中包含了对若干对象的引用

- **URL(**统一资源定位符): 通过URL实现对每个对象的访问, 格式是

  ```
  Prot://user:pwd@www.example.com:port/it/is/path
  协议    [口令]    主机名          [端口] 路径
  http://          www.baidu.com      /picture
  ```

  - 网站大部分支持匿名访问, 这个时候口令就可以不写
  - 协议有默认端口号, 也可以不写
  
- **RRT(round-trip time)**: :一个小的分组从客户端到服务器,再回到客户端的时间(传输时间忽略)

**http协议**

- Web的应用层协议

- 采用C/S模式: 客户端请求, 接收, 展示Web对象, 服务端对请求进行响应

- 采用TCP协议

  - 服务器启动http服务, 在tcp80端口上添加一个守护进程(waiting socket)
  - 客户发起一个默认为80端口的请求
  - 服务器接受客户请求, 新建一个Socket用于与客户机通信, 返回信息
  - 客户浏览器与服务器互相交换http报文
  - 无状态的, 不维护主机与主机之间的通信

- 有持久与非持久的http 

  http在建立连接的时候要进行多次请求, 例如连接建立的请求, 请求多个数据的请求

  - 非持久的http

    每次TCP连接最多可以发送一个对象, 下载多个对象需要多个TCP连接, http1.0默认使用

    ```mermaid
    sequenceDiagram
    Title: 非持久的http
    
    participant C as 客户端
    participant S as 服务端
    
    loop 请求对象1
    	C ->> S: 客户端发起TCP连接请求
        S -->> C: 服务端接受连接通知客户端
        C ->> S: 客户端通过TCP发送http请求报文(需要的对象)
        S -->> C: 服务端将请求对象封装发回
        Note left of S: 存在传输时间延迟
        C ->> S : 发送连接拆除请求
        S -->> C : 连接拆除确认
    end
    loop 请求对象2
    	C ->> S: 客户端发起TCP连接请求
        S -->> C: 服务端接受连接通知客户端
        C ->> S: 客户端通过TCP发送http请求报文(需要的对象)
        S -->> C: 服务端将请求对象封装发回
         Note left of S: 存在传输时间延迟
        C ->> S : 发送连接拆除请求
        S -->> C : 连接拆除确认
    end
    C -> S: 之后还要进行多次请求
    ```
    
    非持久化http请求一个对象需要消耗两个RRT
    
  - 持久化的http

    每次TCP连接可以发送多个对象, 下载多个对象可以只需要一个TCP连接, 持久化连接又分成流水线方式的持久化http(http1.1使用)与非流水线方式的持久化http

    - 非流水线的HTTP要求客户端在收到前一个响应后才可以发送新的请求(如下图)

        ```mermaid
        sequenceDiagram
        Title: 非持久的http

        participant C as 客户端
        participant S as 服务端

        C ->> S: 客户端发起TCP连接请求
        S -->> C: 服务端接受连接通知客户端
        loop 传输对象1
        C ->> S: 客户端通过TCP发送http请求报文(需要的对象)
        S -->> C: 服务端将请求对象封装发回
        Note left of S: 存在传输时间延迟
        end
        loop 传输对象2
        C ->> S: 客户端通过TCP发送http请求报文(需要的对象)
        S -->> C: 服务端将请求对象封装发回
        Note left of S: 存在传输时间延迟
        end
        C -> S: 之后还要进行多次请求
        C ->> S : 发送连接拆除请求
        S -->> C : 连接拆除确认
        ```
    	非流水线的持久http建立需要一个RRT, 每次请求对象需要一个RRT

    - 流水线方式的HTTP遇到一个引用对象就立马发送请求

        ```mermaid
        sequenceDiagram
        Title: 非持久的http

        participant C as 客户端
        participant S as 服务端

        C ->> S: 客户端发起TCP连接请求
        S -->> C: 服务端接受连接通知客户端
        C ->> S: 客户端通过TCP发送http请求报文(需要的对象1)
        C ->> S: 客户端通过TCP发送http请求报文(需要的对象2)
        S -->> C: 服务端将请求对象1封装发回
        S -->> C: 服务端将请求对象2封装发回
        Note left of S: 客户端想什么时候发就什么时候发存在传输时间延迟
        C -> S: 之后还要进行多次请求
        C ->> S : 发送连接拆除请求
        S -->> C : 连接拆除确认
        ```
		流水线的持久http建立需要一个RRT, 请求所有对象最少只需要一个RRT

**http报文格式**: 有请求与响应两种类型

**请求报文**

- 一个ASCII码可读的的请求

  ![req_ascii](./2-1.png)

  - 命令行: 
    - 第一个空格前是命令: get/post/head(只请求html的head部分用于搜索引擎)
    - 地址
    - 协议与版本号
  - 首部行(键值对的方式描述)
    - `Host`: 请求者地址
    - `User-agent`: 用户的代理信息
  - 空行: 必须要有一个空行
  - 实体行: 部分命令(例如post)需要的请求的内容

- 通用格式

  ![httpreq](./2-2.png)

- 向服务器提交
  - 可以使用post命令在实体行写下需要提交的内容
  - 可以使用get命令在url中写下需要提交的参数

**响应报文**

- ASCII格式

  ![resascii](./2-3.png)

  右侧堵住的是`\r\n`

  - 第一行: 协议版本 状态码 状态码对应的状态信息
  - 第二个: 响应的首部行,例如
    - `Server`: 服务器信息
    - `Last-Modifiefed`: 请求的这个对象上一次被修改的时间
    - `Content-Length`: 响应内容的长度, 在回车之后有多长是我的响应信息(因为TCP维护的是字节流的服务, 不维护Message的边界)
  - 第三行是空行
  - 第四行是响应的内容

- 通用格式

  ![reqform](./2-4.png)

**http是无状态的**

服务器不维护连接的状态, 较为简单高效, 收到请求, 返回数据

但是有一部分应用需要维护连接的状态, 例如购物网站维护用户的登录信息, 使用Cookie实现

当客户端第一次访问服务器的时候, 服务器会给客户端分配一个Cookie, 同时保留这个Cookie, 用户拿到Cookie之后将Cookie保存, 之后访问的时候会携带Cookie, 服务端查询Cookie, 获取用户状态(这个用户是谁)

**Web缓存**代理服务器

- 通过使用代理服务器不访问原始网站就可以满足用户需求
- 客户端将所有的请求都先发送给代理服务器, 如果代理服务器缓存中有请求的对象, 那么缓存直接返回对象, 如果没有则请求原始服务器, 并缓存结果, 然后将对象返回给客户端

- 缓存服务器可以降低客户端的请求响应时间, 可以大大减少一个机构内部网络与Internent 接入链路上的流量. 互联网大量采用了缓存:可以使较弱的ICP也能够有效提供内容
- 缓存可能存在过期的风险, 代理服务器可以加入请求头`if-modify-since`, 意思是如果在指定时间(代理服务器的缓存时间)之后修改, 就返回一份, 否则直接返回一个没有修改的信息就可以了

### FTP

FTP文件传输协议用来文件的分发

- ftp服务器守护在TCP21号端口用于请求的监听, 实现
  - 用户身份认证(明文传输)
  - 接受用户指令(例如列出文件, 下载文件的指令)
- 用户可以将指定文件上传下载文件
- ftp服务器在实际传输数据的时候会打开TCP20端口主动与客户端的20号端口建立TCP数据连接, 用于实际数据的传输

我们把这种传输命令与传输数据的分离叫做带外连接

ftp需要维护用户登录状态, 用户所在目录, 所以是有状态的

### EMail

电子邮件包含三个部分

- 用户代理
- 邮件服务器
- 邮件传输协议(分为拉取和发送的协议)

**用户代理**

- 指的是我们发送邮件的客户端软件
- 使用用户代理访问电子邮件应用

**邮件服务器**

- 用户代理通过邮件服务器SMTP协议发邮件
- 邮件服务器从邮件队列中取邮件使用SMTP协议转发到收件服务器
- 收件服务器收件后将邮件收入相应邮箱中
- 收件人用户代理使用IMAP/ POP3/ HTTP拉取邮件

**传输协议**

- 邮件服务器之间通过smtp协议发送邮件
- 邮件客户端使用POP3协议拉取邮件

**发件协议SMTP**

- 守护在TCP25口传输报文

- 直接将邮件从发送方服务器传输到接收方

- 传输的阶段

  - 握手
  - 传输报文
  - 关闭

- 命令响应报文: ASCII形式(要求邮件的内容也是全ASCII)

- 使用持久连接

- SMTP要求报文(首部和主体)为7位ASCII编码

- SMTP服务器使用CRLF.CRLF决定报文的尾部

- 报文格式

  ![SMTPForm](./2-5.png)

- MINE多媒体扩展: 使用Base64编码, 将要传输的内容转化为Base64, 再转换为ASCII, 实现了中文传输, 媒体传输

**收件POP3/IMAP/HTTP**

- POP3邮局访问协议, 是一个简单协议, 只能看到收发件信息(无状态的服务, 维护本地文件夹)
- IMAP具有更多特性, 例如远程目录维护(有状态的服务, 维护远程文件夹)
- http协议不仅可以用于Web访问, 还可以用于文件上下载, 文件服务器等

### DNS

DNS域名解析系统是为其他应用使用的, 实现了域名到IP地址的转换

**DNS存在的必要性**: IP地址标识了主机与路由器, 但是难以记忆, 人们倾向于使用字符串记忆地址, 只用DNS实现地址到IP的转换, 使得应用层可以向下层提交IP而非地址

**DNS要解决的问题**

- 我们不能随意的将设备命名, 应该遵守层次化的原则, 方便管理, 同时使用有意义的字符串
- 域名解析应该是分布式的进行, 而不是集中在一台主机
- 域名应该是被动态维护的

**DNS的主要思路**

- 分层的, 基于域的命名机制(根据域名的层次关系)
- 分布式的完成转换
- 运行在UDP53口(事务型应用)
- 运行在网络的边缘使用应用层协议实现

**目的**

- **域名IP的转换**
- 主机别名的转换
- 邮件服务器别名转换
- 实现负载均衡(决定提供服务的设备)

**域名结构**

- 采用树状结构的命名方法
- Internet被划分层几百个顶级域, 有通用的类似于`.com`,`net`...有国家的类似于`.cn`,`.jp`...
- 每个子域下面又有若干子域
- 域名从本层往上走, 直到树根, 使用`.`描述不同级别的间隔
- 层遵循逻辑的组织界限, 而不是物理网络, 子域主机可以不在父级域主机内部, 同一个网络中的主机不一定在一个域

**DNS服务器**

- 域名服务器的问题

  - 可靠性: 分布式防止单点故障
  - 扩展性: 保证通信容量
  - 易维护: 分布式数据库

- 区域

  为了解决域名服务器的问题, 我们进行了区域划分

  - 一个子域内部的划分应该由子域管理者自己决定
  - 保证仍然是一棵树(不相交)
  - 每一个区域都有一个名字服务器, 维护所在子域内的权威DNS信息
  - 上层域维护自己子域的权威DNS服务器的IP

- TLD顶级域服务器负责顶级域名的维护

**资源记录**

- 资源记录维护了域名与IP的映射关系, 存储在NameServer的分布式服务器中
- RR格式:
  - `Domain_name`: 域名
  - `TTL`: 生存时间(域名的有效时间, 比如权威记录的值就很大, 缓存记录可能就很小)
  - `Class`类别, 对于Internet为IN
  - `value`:  映射值
  - `Type`: 类型
    - A类型: Name是主机, Value是IP地址
    - NS类型: Name是域名, Value是这个域的权威DNS
    - CNAME类型: Name是别名, Value是正规名
    - MX类型: Name是邮件服务器别名, Value是邮件服务器正规名

**工作流程**

- 本机解析器向LocalNameServer查询IP(LocalNameServer一般是手动指定/dhcp指定)

- LocalNameServer(默认名字服务器)如果有缓存信息就直接返回, 没有则向上层请求数据, 有迭代查询与递归查询的方式

- **递归查询**(gaia.cs.umass.edu为例)

  ![递归DNS](./2-6.png)

  1. 主机请求本地DNS服务器
  2. 本地DNS服务器有缓存则返回,无缓存直接找根服务器要信息
  3. 根服务器有缓存则返回,无缓存看到顶级域名是edu, 去找edu的TLD服务器
  4. edu服务器有缓存则返回,无缓存找umass.edu的权威DNS服务器, 一层一层找, 直到cs.mass.edu的权威DNS服务器返回IP
  5. cs.mass.edu的权威DNS服务器返回IP, edu顶级名字服务器缓存
  6. edu名字服务器返回给根服务器, 根服务器缓存
  7. 根服务器返回给根本地DNS服务器, 本地DNS服务器缓存
  8. 本地DNS服务器返回

  - 缺点: 根服务器压力过大

- **迭代查询**(gaia.cs.umass.edu为例)

  ![迭代查询](./2-7.png)

  1. 主机请求本地DNS服务器
  2. 本地DNS服务器有缓存则返回,无缓存直接找根服务器
  3. 根服务器有缓存则返回,无缓存则返回edu的TLD服务器地址
  4. 本地DNS服务器向edu的DNS服务器请求
  5. edu的DNS服务器有缓存则返回,无缓存则返回umass.edu的权威DNS服务器地址, 一次一次找, 直到返回cs.mass.edu的权威DNS服务器IP
  6. 本地DNS服务器向cs.mass.edu的权威DNS服务器请求
  7. 权威DNS服务器返回IP(因为这个域名是在他的域下, 他作为权威DNS服务器一定有)

**DNS协议报文**

DNS协议的查询与响应报文相同

![DNS报文](./2-8.png)

- `ID`: 请求标识
- `flag`: 属性标记

**缓存记录**

为了提高效率, 一旦服务器学习到一个新的映射, 就会把这个映射存储下来, 由于数据可能会发生变化, 自己的数据可能是不权威的, 加入了TTL

### P2P应用

**C/S与P2P模式**

- C/S模式下
  - 所有客户端向服务器请求文件
  - 低可扩展性与高负载
  - 用户都请求服务器的响应时间随着用户数目的增加线性增加
- P2P模式
  - 没有(很少)服务器, 任意两端之间都可以直接通信, 至少有一个服务器(节点拥有拷贝)
  - 利用其他节点的服务能力
  - 节点间歇性上网, 服务器列表动态变化
  - 任何一个节点不仅是服务器, 也是客户机, 随着系统规模的扩大, 请求节点数目增加, 服务节点也在增加, 请求之间随着节点数目对数增加, 可靠性较高
  - 一般用于文件分发, 流媒体, VoIP

**P2P模式的问题**: 资源的定位与节点的动态维护

**P2P文件分发模式**

- 非结构化P2P

  - 节点之间通信构成邻居关系, 构成覆盖网

  - 节点之间随机(任意的)构成邻居关系

  - 节点的维护

    - **集中化目录模式**: 拥有一个集中化的目录服务器用来维护节点,用户上线的时候通知服务器, 提交自己的资源信息, 用户需要资源的时候请求目录服务器, 目录服务器返回拥有资源的节点

    - **完全分布式**: 在线节点构建覆盖网, 使用泛洪的方式发起查询, 拥有资源的节点返回应答, 为了防止无限的泛洪, 可以设置TTL/中转节点打标记, 不重复泛洪.

      在安装应用时, 会加载网络中非常活跃持久的节点, 节点要加入网络时, 向活跃节点发出ping, 活跃节点继续ping他的邻居, 以此类推, 收到ping的节点都要向源节点发出pong响应, 建立TCP连接

      节点想下线的时候向邻居发送推出公告

    - **利用不匀称性的混合型**的KaZaA: 每个节点要么是组长, 要么是一个组长的节点, 组内使用集中化目录, 组长之间完全分布式, 请求信息的时候组内有就用组内, 组内没有则组长向全网请求

- DHT(结构化)P2P

  - 节点之间构成一个有序的覆盖网(例如构成一个环的关系, 树的关系)

**BT文件分发协议(非结构化P2P)**

- 将文件按顺序切割成256KB的块, 用户交流拥有信息的时候只需要传输一个数据, 第i位为1/0代表用户拥有/不拥有文件的第i个块
- 用户上线后将自己拥有文件的信息进行泛洪
- **稀缺优先**: 用户请求文件的时候, 对于拥有文件的节点, 优先请求稀缺的块
- **利他主义**: 节点优先向经常向他提供服务的人服务, 过一段时间之后再随机选一个进行评估
- **文件请求的时候通过带外的方式下载文件描述信息**

### CDN与视频服务

视频流化服务占据着互联网大部分带宽, 单个服务器无法为用户提供服务, 用户根据自己设备的不同使用的分辨率不同, 于是需要分布式的, 在应用层面的基础设施CDN(文件分发网络)

视频可以认为是图像的序列, 图像可以认为是像素点的序列, 视频在传输的过程中需要进行压缩以降低对带宽的需求

- 空间冗余的压缩: 在一帧图像中, 有很多连续的相似像素点, 可以描述为连续多个同色像素.......
- 时间冗余的压缩: 只描述与上一帧相比变化了哪些部分

创建的视频传输方式

- CBR: 固定速率编码
- VBR: 可变速率编码,(静态图像传慢点)

**多媒体流化服务DASH**

- 服务器将视频转化为不同码率, 切片, 提供告示文件, 包含了视频的所有类型码率的所有块的持续时间, url...
- 客户端使用告示文件, 根据客户端分辨率, 到各个服务器带宽, 周期性获取视频文件块

**内容分发网络CDN**

CDN运营商在全网部署缓存节点,提前存储服务内容,使用重定向的方式就近为用户提供服务,提高用户体验, 实现方式有

- enterdeep: 将CDN服务器深入到许多接入网, 更接近用户,数量多,离用户近,管理困难
- bringhome: 部署在少数(10个左右)关键位置,如将服务器簇安装于POP附近(离若干1stISP POP较近)

CDN服务器上预先部署需要分发的内容, 用户在请求的时候先想原服务器获取告知文件, 用户选择最近的服务器进行请求

### TCP编程

应用层需要借助SocketAPI与传输层通信, 实现数据传输, 传输层有两种服务, 于是有两种Socket编程, TCP与UDP编程

**流程**

- 服务器

  - 服务器运行, 创建一个欢迎Socket(这个时候Socket被初始化, 所有值都没有)
  - 将Socket与本地端口捆绑
  - 使用这个Socket**阻塞式**等待用户的链接

- 客户端

  - 客户端创建Socket(这时候Socket初始化, 空值)
  - Socket与本地无用端口捆绑(他不需要守候特定端口, 所以直接捆绑无用端口)
  - 指定Socket的远程端口信息
  - 与目标设备建立链接

- 服务器收到TCP连接请求, 接触欢迎Socket阻塞

  - 返回一个与欢迎Socket四个参数相同, 但是Socket值不同的Socket

  注意: 可以有多个Socket守护在一个端口, 通过目标端口, IP进行区分

**Socket的数据结构**

- sockaddr_in(IP与Port的pair)

  ```c++
  struct sockaddr_in {
      short sin_family; // 地址类型(TCP/IP的值是AF_INET)
      u_short sin_port; // 端口号(0-65535)
      struct in_addr sin_addr ;	// IP地址()
  	char sin_zero[8];			// 对齐值(IPX的协议IP长一些要写, IP协议全0即可)
  };
  ```

- hostent(域名与IP的pair)

  ```c++
  struct hostent{
  	char *h_name;			// 主机的域名
  	char **h_aliases;		// 主机的别名列表
  	int h_addrtype;			//
  	int h_length;			// 地址长度
  	char **h_addr_list;		// 不同的IP地址
  	#define h_addr h_addr_list[0];		// 解析结果就是上一行数组的0元素
  }
  ```

**运行流程**

![](./2-9.png)

### UDP编程

与TCP不同的是Socket不维护目标IP与端口号, 所以收发的时候要额外获取目标

![](./2-10.png)

## 传输层

TCP向上层提供的是可靠的数据服务, 但是下层的IP协议提供的是不可靠的服务, 所以需要实现在不可靠的服务上提供可靠服务, 还需要实现拥塞控制的检测实现

- 传输层的服务: 为应用进程提供逻辑的通信服务, 实现了进程到进程之间的以报文为单位的传输Message的服务
- TCP在接受到应用层传来的报文后, 将报文分解成若干个报文段, 添加段头后传输, 对方实体收到后合并, 传给上层
- 传输层提供了复用与解复用: 复用指的是多个应用层实体可以同时调用一个TCP实体(当然前提是同一个目标IP), 解复用指的是TCP收到报文后可以分解并传输为多个应用层实体
- 传输层实现了IP不具有的可靠通信: 防止数据丢失, 乱序..., 但是有些服务也是无法加强的, 例如延迟, 带宽

**TCP与UDP**

- TCP提供的服务
  - 提供字节流的服务
  - 多路复用解复用
  - 流量控制
  - 拥塞控制
  - 连接的建立, 维持, 拆除
- UDP提供服务
  - 提供数据报的服务
  - 多路复用解复用
- 都不提供
  - 延迟保证
  - 带宽保证

### 多路复用与解复用

IP提供主机到主机的服务, 不区分上层是谁交给IP协议的, 传输层通过使用Socket中的端口号与IP实现了将数据报区分到不同的进程, 传输给应用层不同实体

- TCP接受上层的Message与Socket, 将Socket的两个端口与Message封装在一起加上源与目标IP交给网络层, 网络层将双方IP与传输层SDU再进行封装(网络层不管端口, 要传输层封装好)

  TCP收到IP传来的数据报后使用Socket的**四**元组在表中查询进程交给应用层

- TCP接受上层的Message, Socket, 对方IP与端口号, 将Socket的源端口, 传来的目标端口与Message封装在一起加上源与目标IP交给网络层, 网络层将双方IP与传输层SDU再进行封装(网络层不管端口, 要传输层封装好)

  UDP收到IP传来的数据报后使用目标IP与端口在表中查询进程交给上层

### 无连接传输: UDP

- UDP(用户数据报协议)在IP提供服务的基础上只提供的复用与解复用的服务

- UDP仅提供尽力而为的服务, 不保证可靠性, 如果想在UDP上实现可靠性, 只能在应用层实现可靠传输

- UDP连接之前不需要握手,  一般用于流媒体传输/DNS/SNMP等事务性应用

**UDP数据报格式**

![](./3-1.png)

- 包含16Bit的源端口号, 目标端口号
- 包含了16Bit的整个数据报的长度
- 包含了16Bit的校验和(CheckSum), 在源端做校验和计算, 目标段检验

**UDP存在的必要性**

- 不建立连接 (会增加延时)

- 简单:在发送端和接收端没有连接状态

- 报文段的头部很小(开销小)

- 无拥塞控制和流量控制:

  UDP可以尽可能快的发送报文段( 应用->传输的速率= 主机->网络的速率 )

**UDP校验和**

- 使用简单的加法计算校验和
- 发送端将报文段的内容视为16比特的整数, 对报文段进行加法求和, 将校验和放在UDP的校验和字段
- 接收端收到数据之后计算校验和, 进行比较, 校验和不通过一定有问题, 不通过不一定没问题

**校验和的计算举例**

假设UDP的数据报头与数据体为

```
1 1 1 0 0 1 1 0 0 1 1 0 0 1 1 0
1 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1
1 0 1 1 0 1 1 0 0 0 1 0 1 1 0 1
```

这里将他们每16Bit划分为一组(CheckSum这个时候是全0)

```
先对前两组计算
        1 1 1 0 0 1 1 0 0 1 1 0 0 1 1 0
        1 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1
    --------------------------------------
      1 1 0 1 1 1 0 1 1 1 0 1 1 1 0 1 1
回卷     1 0 1 1 1 0 1 1 1 0 1 1 1 1 0 0
        1 0 1 1 0 1 1 0 0 0 1 0 1 1 0 1
    --------------------------------------
      1 0 1 1 1 0 0 0 1 1 1 1 0 1 0 0 1
回卷     0 1 1 1 0 0 0 1 1 1 1 0 1 0 1 0
校验和   1 0 0 0 1 1 1 0 0 0 0 1 0 1 0 1
```

**进位回滚**: 由于二进制存在进位, 当最高位进位后, 将溢出的这一位加到结果的最后一位

**校验和求反码**: 将计算结果求和后取反, 接收端收到后求和(包括CheckSum), 得到的如果是16个1说明校验通过

### RDT可靠数据传输

在TCP中, 在传输层实现可靠数据传输, 下层是不可靠的, 需要向上层提供可靠服务, 使用RDT保证传输的可靠性, RDT是原理, 不一定是TCP采用的协议, 其他网络也采用了RDT的原理

**RDT协议**

采用渐进的方法完善协议, 使用有限状态机(FSM)描述发送与接收方

- RDT1.0: 下层完全可靠(不出错, 不丢失)

  本层只需要简单将数据转发即可

  ![rdt1.0](./3-2.png)

- RDT2.0: 下层在传输的时候可能出现比特错误

  - 在发送的时候加入差错控制编码(checksum)
  - 当接收方发现数据符合差错控制编码关系则返回ACK
  - 当接收方发现数据不符合差错控制编码关系则返回NAK, 发送方收到NAK后重发数据, 继续等待, 直到获得ACK

  ![rdt2.0](./3-3.png)

- RDT2.1: ACK/NAK传输出错

  - 发送方将要传输的数据包编号, 只要没收到ACK就重发
  - 接收方正常返回ACK/NAK, 如果接收方已经返回了ACK但是又收到了同样的数据包, 说明ACK传输出错了, 重新返回ACK即可

  ![RDT2.1](./3-4.png)

  协议并没有安排ACK/NAK的确认

- RDT2.2: 无NAK协议

  - 之后我们可能不用停等协议了, 换成流水线模式的, 那么每个数据包都返回ACK/NAK就很麻烦, 可以取消NAK
  - 接收方将ACK作编号, 接收方ACKn-1作为NAKn传输, 例如发送方传输了3号包, 却收到了ACK2, 说明传输失败了

  ![rdt2.2](./3-5.png)

- RDT3.0: 具有比特差错与分组丢失

  - 分组传递丢失后, 接收方收不到数据, 发送方收不到ACK/NAK, 产生死锁
  - 引入超时重传机制, 设置超时时间为比正常传输往返时间略长的时间, 发送方检测到超时后自动重新传输, 这样不论是数据包还是ACK/NAK传输失败都会重发
  - 收到ACKn-1后不会重发分组, 会等待直到超时

  ![rdt3.0](./3-6.png)

  - 超时定时器的设置很重要

**流水线协议**

停等协议在信道容量很小的时候效率很低, 流水线协议可以避免, 分为GBN协议和SR协议, 他们都用到了滑动窗口

**滑动窗口协议**

- 发送缓冲区
  - 发送缓冲区: 存储已经存储分组发送但未经对方确认的数据(用于重发), 只有进入发送缓冲区才可以发送(但是进入发送缓冲区不一定就发送了)

  - 发送窗口: 发送缓冲区中已经发送但是没有确认的分组

  - 开始时: 没有任何分组, 滑动窗口的前沿=后沿, 滑动窗口尺寸为0

    每发送一个分组, 滑动窗口前沿向前移动一个单位

  - 收到数据后, 滑动窗口的后沿滑动, 发送分组后滑动窗口前沿向前滑动.

![sw](./3-7.png)

- 接受窗口(缓冲区)

  在接收端, 哪些分组可以被确认收到, 接收端只接收接受缓冲区内部的分组

**GBN协议**

接受缓冲区大小为1, 如果收到不是滑动窗口罩着的分组就拒收, 返回ACK最后一个接受成功的分组

异常处理:

- 接受窗口遇到乱序到达就抛弃
- 发送窗口发现发现ACK超时就重发发送窗口中所有的包(因为接受窗口大小为1, 如果n号包丢了,n+1就算到达也不会被接收)

**SR协议**

- 如果接受窗口大于1, 收到数据后, 接收方尝试滑动窗口到第一个没有接受的分组(当然可能滑不动)
- 收到滑动窗口内的数据时, 会分别发送ACK
- 当接受滑动窗口可以滑动的时候, 向上层发送这个有序的序列

异常处理

- 存在丢包后只发丢失的分组

| 发送窗口大小 | 接受窗口大小 | 协议 |
| ------------ | ------------ | ---- |
| 1            | 1            | 停等 |
| >1           | 1            | GNB  |
| >1           | >1           | SR   |

| 比较                          | GBN              | SR                        |
| ----------------------------- | ---------------- | ------------------------- |
| 优点                          | 简单, 需要资源少 | 出错重传代价小            |
| 缺点                          | 出错重传代价大   | 复杂,所需资源多           |
| 适用链路                      | 出错率低         | 链路容量大(延迟大,带宽大) |
| 最大窗口<br />(n是编号比特数) | $2^n-1$          | $2^{n-1}$                 |

### TCP

**特性**

- TCP提供点对点的数据通信
- TCP提供的是可靠的**字节流服务**(不提供报文的界限)
- 管道化: 有流量与拥塞控制
- 有发送与接受缓存(重发机制)
- 全双工
- 面向连接

**TCP报文段**

![TCPstr](./3-8.png)

- **序号**: 这个报文中数据部分在原Message中的偏移量(一般是X+n*MSS, X是双方约定发送的时的开始序号, X不为0的是为了方式老的连接被新的连接接受)

- **确认号**: 确认号为N表示接收方收到了N-1及之前的字节(与前面协议不同, 前面RDT只是说原理, 并不是TCP的实现), 有点像GBN协议

  注意: 这里的N-1减去的是字节, 而不是分组的编号, 例如当X=100时候

  发送方发送第一个分组,大小是20Byte, 也就是说序号为100, 接收方接收到的是编号为100-119的一个包, 他返回的应该是119+1=120

  发送方发送第二个分许, 大小是10Byte, 也就是说序号(偏移量)是120, 接收方返回的是(序号120+大小20-1+1), 发送方发送的是120-139的数据, 接收方返回139+1=140

- **U/A/P/R/S/F**: 表示状态, 组合在一起表示其他意义

- **接受窗口**: 接受窗口大小

- **校验和**: 同UDP的check-sum

**TCP的超时时间确定**

TCP的通信环境在一天中变化很大, 应该动态测量往返延迟
$$
EstimatedRTT = (1-\alpha)\times EstimatedRTT + \alpha \times SampleRTT
$$
一般取$\alpha=0.125$, 也就说这次**计算**的延迟=这次**测量**的延迟占$\times$0.125 + 上次**计算**的延迟$\times$0.875, 而上次使用的延迟又是上次测量和上上次计算的计算得到的
$$
TimeoutInterval = EstimatedRTT + 4\times DevRTT
$$
实际使用的时间又是这次确定的时间加上四倍方差

#### 可靠数据传输

TCP协议使用了GBN与SR协议的混合体

- **管道化的**: 可以一次发送多个段

- **累计确认的**: 接收方只给最大确认

- 只为最老的段设置**一个定时器**, 而不是为每一个段设置一个定时器

  一旦最老的段超时, **只重发最老的段**

- 没有规定乱序的处理

- **快速重传**: 当发送方收到三个冗余的ACK就不管超时定时器, 立刻将最老的段进行重传, 因为收到冗余一般都是出现了丢包或者拥塞, 例如

  发送端发送了101,102,103,104,105,106分组,(分组大小都是1Byte)

  101接收成功, 收到ACK102(小于等于101的都成功了)

  102丢了, 没有反馈

  103接收成功, 收到ACK102(小于等于101的都成功了, 当然103也成功了, 但是不连续)

  104接收成功, 收到ACK102(小于等于101的都成功了, 当然104也成功了, 但是不连续)

  105接收成功, 收到ACK102(小于等于101的都成功了, 当然105也成功了, 但是不连续)

  发送端收到一个正常ACK101和三个冗余的ACK101, 立刻重发102段

  102接收成功, 收到ACK106(小于等于105的都成功了)

  106接收成功, 收到ACK107

- ACK建议
  - **如果收到一个顺序分组(最低编号)**: 暂时不发, 等待500ms, 如果下一个顺序分组来了就一起回复一个ACK, 如果下一个顺序分组没来再单独发
  - **如果乱序到达**:  立马重发冗余ACK 
  - **如果到来的分组可以填充滑动窗口的空隙, 向前滑动大于一个分组**: 立刻发送ACK

#### 流量控制

用来防止接收方接收过慢发送方发送的过快

接收方利用ACK/NAK的receive-window字段告诉发送方有多少看空字节(捎带技术)

#### 连接管理

**连接建立**: 双方要知道双方信息, 准备资源, 初始化参数

**三次握手**:

- 请求方设置TCP报文SYN为1, 表示建立连接, 同时设置序号(也就是X)
- 接收方同意建立请求, 设置TCP报文SYN为1, 表示建立连接, 同时设置序号(也就是Y), ACKX+1
- 请求方收到同意后发送ACKY+1表示同意请求, 同时传输参数

![tcp3](./3-9.png)

**连接释放**

- 客户端发送连接拆除, 服务器回复ACK, 此时客户端到服务器的连接就没了
- 服务器发送连接拆除, 客户端回复ACK, 此时服务器到客户端的连接就没了
- 连接断开之后设置一个定时器, 在定时器超时之前如果没有数据报再来就认为连接断开

这里虽然第一步客户端拆除了连接, 但是还是可以传输数据, 毕竟在建立服务时服务器也在TCP没有建立的情况下回复了ACK

**连接释放的两军问题**: 连接释放是不可靠的, 对方确认的段是不可靠的

### 拥塞控制

太多的数据通过网络传输, 超过了网络的处理能力, 需要拥塞控制. 拥塞控制是**网络的问题**

流量控制是接收方接收的速率不够大而进行控制, 是接收方的问题

**网络拥塞原因与代价**

- 传输速率接近链路速率比会导致排队延迟增大
- 队列溢出导致分组丢失
- 排队延迟增大导致重传
- 队列溢出导致被抛弃的分组的上游传输能力也被浪费了

**拥塞控制方法**:

- 端到端的拥塞控制: 不提供网络信息的控制
- 网络辅助的拥塞控制: 网络提供拥塞信息给端系统

**网络辅助的拥塞控制**

- 以ATM网络为代表, ATM网络以信元为传输的最小单位
- ATM网络使用ABR拥塞控制, 如果网络不拥塞, 允许设备瞬时超过分配带宽传输, 如果网络拥塞, 限制发送方的发送速率到一个最小保证速率上
- ATM中有两种信元: 数据信元与资源管理信元, 管理信元通过设置标志位值告诉端系统当前网络速率

### TCP拥塞控制

TCP使用的是端到端的拥塞控制, 不需要网络提供信息

**拥塞检测**: 

- 网络拥塞: 发出的包超时了
- 轻微拥塞: 收到三个冗余ACK

发送段限制方式$rate = \frac{CongWin}{RTT}$ 

其中CongWin是单位时间内向网络打入未确认的分组速率

**CongWIn检测**: 

- 超时时: CongWin降速未1MSS, 进入SS阶段, 倍增到CongWin/2, 进入CA阶段, 
- 遇到三个冗余ACK: CongWin降速到原来的一半
- SS阶段: 速率倍增(慢启动)
- CA阶段: 速率线性增加

**TCP拥塞控制与流量控制结合**

- 拥塞控制用于防止网络拥塞
- 流量控制用于防止接收方接收速率过低, 无法接受
- 两者取最小值联合控制得到TCP的实际发送速率

**TCP拥塞控制**

- 当连接开始时,指数性增加(每个RTT)发送速率直到发生丢失事件
- 丢失事件/超时事件发生后将CongWin 降为1,将CongWin/2作为阈值(Threshold),进入慢启动阶段(倍增直到阈值CongWin/2)
- 当CongWin>阈值时,一个RTT如没有发生丢失事件,将CongWin加1MSS: 探测
- 当收到3个重复的ACKs后 CongWin 减半, 窗口(缓冲区大小)之后线性增长

**TCP吞吐量**: 慢启动太快了, 我们忽略不计, 拥塞控制使得发送速率在链路速率的一半到满速之间线性证件, 减小, 使得TCP的吞吐量到达了链路轻度拥塞(2个ACK)速率的$\frac{3}{4}$

**TCP的公平性**

![fairy](./3-10.png)

上图中, 蓝色的直线是$R'=w-R$, 其中$R$是发送端1的发送速率, $R'$是发送端2的发送速率, 坐标系中的点可以代表两个发送速率

- 当点在$R'=R$上的时候, 两方的发送是公平的
- 当点在蓝色线下面的时候, 由于链路带宽充足, 双方都处于CA阶段, 都会线性增加, 点向着45度方向增加, 直到超过蓝线
- 超过蓝线之后, 双方都发生了3ACK, 两个速率一起减半, 高速者多减一点, 最后收敛到$R'=R$

**TCP公平中存在的问题**

- UDP在网络中是不限速的, 会对TCP造成侵略
- 用户可以同时发起多个TCP连接到服务器, 而TCP的公平性是根据TCP连接数目均分而不是按照用户数均分
- 设备与服务器连接的RTT并不相同, 所以超时标准在主机之间不尽相同


## 网络层 数据平面

网络层有数据平面与控制平面

- 数据平面: 进行微观的**转发**
- 控制平面: 进行宏观的**路由**

### 网络层概述

**网络层提供的服务**:

- `服务`: 提供主机到主机之间的服务, 在主机之间传输TCP/UDP的段(segment)
- `上层`: 获取传输层传入的TCP/UDP段(segment) / 将segment交给传输层
- `作用`: 将TCP/UDP段Segment封装成IP数据报 / 解封装
- `下层`: 将IP数据报传给下层传输 / 接受IP数据报

网络层协议存在于每一个主机/路由器中, 因为要解IP包, IP数据报要在每一跳的时候进行解封装, 获取信息, 封装, 转发的流程

**网络层的功能**:

- `转发`: 是一个局部的概念, 一个路由器接入了不同的网络, 将一个发来的数据报选择一个路径发送到另一个网络的过程叫转发, 例如将以太网的网卡发来的以太网网卡标准的数据报解封装,选择路径, 封装成无线网卡标准的IP报由无线网卡发出
- `路由`: 是一个全局的概念, 规划源主机的网络到目标主机网络的路径规划
- 路由决定的整体路径规划生成路由表, 转发是在收到数据后,解封装, 获得目标IP,查路由表. 决定了在某个节点上从哪个端口进入,从哪个端口出来,

**转发与路由选择**

- 传统情况: 控制平面计算**路由表**, 数据平面根据目标IP查询路由表获取下一步转发位置, 进行**转发**. 整个网络是无法修改的

- 软件定义网络: SDN下. 数据平面根据IP, 端口... 很多信息查询**流表**, 获取下一步**动作**(包括转发, 阻止, 泛洪(广播), 修改数据...很多动作), 流表是通过南向接口获取, 由网络操作系统算出来的. 整个网络是可编程的

- 传统情况:

  - 路由器兼具转发与路由的功能

  - 通过与其他路由器交换路由信息, 使用路由器分布式的计算路由表

  - 数据平面控制平面紧偶和

  - 无法对路由规则进行统一的修改

- SDN: 

  - 控制平面运行在网络控制器上集中式计算流表
  - 交换通过南向接口获取流表, 获取动作
  - 修改路由规则只要修改网络控制器即可, 网络是可编程的

**网络服务模型**

- `评价指标`
  - 对于单个数据报指标: 可靠传输, 延迟
  - 对于数据报流指标: 保序, 流的最小带宽(最小网速), 分组之间的延时差
- `功能`
  - 数据层面
  - 控制平面
  - 连接建立: 是否是保持连接的, 这里的保持连接是指主机之间包括中间的交换设备是保持连接的(传输层只看主机之间是否连接,叫面向连接, 这里包括中间主机是都保持连接叫做有连接)
- 可以用尽力而为描述网络层的服务模型

### 路由器工作原理

#### 路由器的组成

**路由器的组成**: 输入, 输出, 交换机(fabric) 交换机转发依据路由表进行局部转发. 一般情况下一个端口既是输入端口也是输出端口

**输入输出端口**: 包含三个模块

- `线路端接`: 物理层模块, 接收比特数据

- `数据链路处理`: 数据链路层模块, 执行数据链路层协议 进行封装/解封装, 例如检测目标Mac与网卡Mac一致性

- `查找转发队列`: 网络层实体, 根据IP报通过Fabric进行转发, 设计了个队列对数据进行缓存

  缓存队列的目的: 这设置的时候交换实体的处理速度应该大于所有端口的速度和, 但是可能出现**头端阻塞**(多个输入口向一个输出口发送数据, 输出口满载, 输入速度过大, 数据要在输入口等待), 所以要设计输入缓存队列.输入输出缓存队列不需要过大(缓存太大队尾数据报还没处理就超时了), 队列缓存区用完会直接丢弃

**交换结构**

任何一种交换结构的交换实体处理速度应该大于所有端口IO速度和

- 基于Memory的交换结构

  将分组传入Memory, 软件判断转发端口, 发出

  `缺点`: 数据在系统总线跑了两次, 低效

- 基于Bus的交换结构

  将分组传入总线, 总线连接所有的输出端口, 分组到达所有的数据端口, 输出端口匹配是不是要自己发出的分组

  `缺点`: 同一时刻只能处理一个分组

- 基于CrossBus的交换结构

  设计Banyan(榕树)网络, 将输入输出端口之间两两连接, 要把数据从输入口发到输出口只需要短接对应链路即可

#### 调度算法

**输入输出端口缓存队列调度规则**

- `丢弃规则`
  - tail drop 丢弃最后来的
  - priority 根据优先权丢弃
  - random 随机丢弃分组

- `调度规则`
  - FIFO(first in first out) 按照分组到来的次序服务
  - 优先权调度:  按照分组的优先级调度, 优先级可能是依赖于头部字段等, 低优先级的FIFO传输
  - RR 轮询调度: 一个接口传一个
  - WFQ(weight fair queuing) 加权公平队列调度: 在一段时间中一个队列被服务的时间权重是队列中分组的个数

### IP协议

IP协议在传输层与链路层之间的网络层, 网络层不止有IP协议还有一些路由选择协议

IP协议主要是实现了数据平面的路由转发功能, IP协议主要有地址, 分组的处理等

#### IPv4数据报

**IP数据报格式**

![IPv4数据报格式](./4-1.png)

图中的一行是32Bit = 4Byte 前6行是IP数据报的头部, 一般是20Byte(如果没有选项的话)

- `var`: 版本号: 4bit, IPv4的值就是0100
- `head len`: 头部长度, 单位**4Byte**, 也就是说我这里写一个9意思就是9*4=32Byte, 由于固定头部就有20Byte, 所以这个数最小是5
- `Type of service`: 分组类型, 方便网络, 目前基本不用
- `length`: 数据报总长
- `16-bit identifier`: 16bit的标识符
- `flags`: more flag标志位(告诉你这是不是最后一个分片)
- `fragment offset`: 偏移量 单位**8Byte**
- `TTL`: 分组存活的跳数
- `upper layer` 上层协议(TCP/UDP...)
- `Internet checksum`: 分组头部校验和
- `32 bit source IP address`: 32位源IP
- `32 bit destination IP address`: 32位目标IP
- `Option`: 选项部分

**分片和重组**

不同种类的网络MTU(最大传输单元)不同, 要将数据在不同的网络之间传输就需要分片和重组

分片的时候需要为每一个分片添加相关的属性, 有

- 20Byte 的头部
  - `16-bit identifier`: 同一个分组的分片id是相同的
  - `fragment offset`: 数据体与原数据相比偏移量
  - `flags`: more flag标志位(告诉你这是不是最后一个分片)
- MTU - 20Byte 的数据体部分

#### IPv4地址

**IPv4地址**

IP地址是用来标注接入设备的点的, IP是一个32Bit的串, 在一个子网中, IP之间应该是一跳可达的

- 子网:

  - 子网中IP地址的前缀(子网号)是相同的
  - 子网内部数据的收发不需要路由器(例如只借助交换机)

- 子网掩码: 用来标识IP的哪几位是是IP的网络地址, 哪几位主机号, 网络号所在位用1标识, 之后的二进制位标识主机号,例如

  - `192,168.1.123/255.255.255.0` 说明`192.168.1.0-192.168.1.255`是网段, 123是主机名

  - 129.168.1.99/255.255.255.192 
    将子网掩码转化为二进制`11111111.11111111.11111111.11000000`

    说明网段是网段是前26置, 主机号是后6位

    IP转化为二进制`1100000000.10101000.00000001.1100011`

    说明网络号是`192.168.1.192` , 网段是`192.168.1.192`-`192.168.1.255`, 广播地址`192.168.1.255`
    
  - 如果子网掩码是从高位开始连续的n个1, 可以使用/n表示,例如`255.255.255.0`直接写成`24`


**IP地址的分类**

- **约定**

  主机部分全0表示整个网络(例如`192.168.1.0/24`)

  主机部分全1表示子网广播地址(例如`192.168.1.255/24`)

  子网部分全0 表示本网络`0.0.0.222/24`

  `255.255.255.255`表示广播域的所有主机

- **A类地址**: 首二进制位为0, 第一个Byte(前8位)代表网络号, 后面是主机名

  具有$2^7-2=126$个网络, $-2$是因为`0.X.X.X`网段的0.0.0.0给了主机地址, `127.X.X.X`网段是局域网保留地址

  具有$2^{24}-2$个主机, $-2$是因为主机号全0, 全1另有用处

- **B类地址**: IP二进制地址前两位是10, 前两个Byte是网络号

  具有$2^{14}$个网络

  一个子网具有$2^{16}-2$个主机

- **C类地址**:  前缀`110` 前3Byte(24位)为网络号

- **D类地址**: 前缀`1110`

- **E类地址**: 预留地址

- **回路地址**`127.x.x.x`, 意思是不论什么请求, 只要到达网络层, 网络层会立即反转向上发回 

- **专用地址**

  在不同种类的地址中都抽一部分作为内网专用地址, 永远不会作为公网地址

  - A类中的专用地址`10.0.0.0 - 10.255.255.255/8`
  - B类中的专用地址`172.16.0.0 - 172.31.255.255/16`
  - C类中的专用地址`192.168.0.0 - 192.168.255.255/24` 

- ABC类是单播地址, DE类是组播地址我们可以通过IP前几位判断他是ABCDE类, 如果是ABC类,我们就不需要子网掩码了

- 我们没办法为每一个IP计算路由表, 但是可以计算一个一个子网网段的路由表

**子网和内网是不同概念**: 

- AS1的网络中有X设备我们我可以说X在AS1子网中, 但是X在外网可不可见是不一定的
- AS1的网络中有X设备, AS2对外不可见, 我们可以说X是AS1内网中的, X在AS1的子网中
- 内网是区别于外网的概念, 内网中的设备对外不可见(对外暴露网关除外), 对于不同类型IP(网关的IP), 有着自己类型内部专用地址用来表示内网地址, 外网无法通过专用地址访问内网设备
- 子网描述的是网络中的拓扑关系, 至于子网中的节点可不可见, 那要看子网是用的专用IP还是普通IP, 看防火墙策略

**无类域间路由CIDR**: 将IP划分为类可能无法准确满足需求, 可以根据需求指定子网掩码, 为一个机构分配合理的子网号, 寻址的时候做一个按位与就获得了网络号,路由只需要对比目标`IP&mask === distination`就可以了, 如果 都没有匹配到就发送到路由表中的默认出口(一般是向公网的出口)

#### DHCP

我们可以通过设置让机器具有一个静态IP/掩码/网关/DNS地址. 也可以使用DHCP从服务器动态获得一个IP...

- 特性
  - DHCP允许主机在上线的时候动态获取IP地址
  - 允许在IP过期后续租
  - 允许重新登陆后使用之前使用的IP
  - 支持移动用户短期在网
  - 使用UDP通信
- 工作方式
  - 主机登陆后使用`0.0.0.0`向`255,255,255,255`广播"DHCP discover"
  - DHCP服务器使用`DHCP offer`返回IP响应
  - 主机请求IP地址, 发送`DHCP request`请求
  - DHCP服务器发送IP地址`DHCP ack`响应

#### 路由通告与聚合

路由之间要相互进行通告, 自己是哪个子网的路由器(XXX网段的数据包都交给我来转发), 这样相互之间才可以相互组网, 路由器还可以对通告聚合, 如果路由发现他拥有某个网段的所有子网,他可以合并向外通告,例如, 路由器有以下路由通告

```
11111111-11100111-11111100-XXXXXXXX / 24
11111111-11100111-11111101-XXXXXXXX / 24
11111111-11100111-11111110-XXXXXXXX / 24
11111111-11100111-11111111-XXXXXXXX / 24
```

她就可以向外通告

```
11111111-11100111-111111XX-XXXXXXXX / 22
```

是他的下一跳, 当他获得`/22`的数据报的时候, 他会继续查表, 转发

有点时候并不需要获得全部子网网段也可以向外发出聚合通告, 这个时候转出路由会查表发现有两个通告形如

```
11111111-11100111-111111XX-XXXXXXXX / 22	都给A 实际上A根本没有这个IP
11111111-11100111-11111111-XXXXXXXX / 24	都给B
```

路由器会匹配最长的前缀进行转发

#### NAT网络地址转换

内网中的设备使用的内网IP无法在外网上通信, 路由器上拥有公网IP, 那么

- 在内网设备访问外网的时候: 在出路由的时候如果路由器看到数据报的源IP是一个内网地址就会将地址与端口替换为自己的公网地址与一个空闲的端口号, 在收到数据的时候将目标地址和端口号替换为内网的内网地址/端口
- 在外网设备主动访问内网的时候会出现访问失败. 想访问就必须设置NAT穿越
- NAT穿越: 
  - 可以在网关配置`公网IP:无用端口`永远对应`内网IP:目标端口`
  - UPnP/IGD协议: 允许动态修改NAT转化的表象
  - 可以使用中继连接, 内网永远与中继连接, 外网与中继连接

#### IPv6

- 特性
  - IPv6头部是40Byte
  - 不允许分片(遇到大分组会直接返回报错, 否则这么大的头很难做分片)
  - IP地址从32bit变为64bit

- 结构

  ![IPv6](./4-2.png)

  - `priority`用来标注流中数据包的优先级
  - `flow Label` 未明确定义
  - `Nextheader` 上层协议或者是IPv4的Option(遵循TLV格式: Type Length Value)
  - `checksum` 被移除
  - `Option` 整合到Nextheader
  - 增加`Packet too big`响应

- IPv4过渡到IPv6

  在IPv6网内部使用IPv6通信

  使用双栈协议(隧道技术)处理IPv4与IPv6的通信, 将IPv6的数据报整体封装成IPv4的数据报进行通讯

### 通用转发与SDN

数据平面完成数据转发, 控制平面计算路由表

- `传统方式`

  实现这两大功能采用的是垂直集成的方式: 每个路由器自己计算路由表, 进行路由通告, 交给IP实体进行转发

  设备只能按照规范模式工作, 无法升级功能/协议. 对于功能不同的网络设备(防火墙, 负载均衡服务器), 需要单独部署协议与功能

  硬件, 操作系统, 软件都是是私有的, 品牌间互不兼容

  根据IP进行转发, 不能将一个IP的请求分成多路发送

- `SDN`

  远程控制器与CA(控制代理)交互, 控制器决定分组的转发逻辑(可编程), CA所在设备执行逻辑

  分组交换机具有相同接口, 不同操作之间可以相互兼容

  根据IP等字段进行转发, 可以将一个IP的请求分成多路发送

**通用流表**

- 流: 由分组头部字段定义
- 通用转发: 简单的分组处理规则
  - `模式`: 将头部字段与流表进行匹配
  - `行动`: 将匹配上的分组进行丢弃/ 转发/ 修改
  - `优先权`: 匹配到多个结果后决定使用哪一个
  - `计数器`: 对匹配的分组计数
- 通过流表变成可以让路由器具有路由器, 交换机, 防火墙...功能呢个



## 网络层 控制平面 

### 路由选择算法

有`link state`链路状态算法和`distance vector`距离矢量算法

**路由**: 路由指的是按照某种指标(跳数, 延迟, 花费...的加权平均)在一个网状网中找到一条较好的子网到子网的路径

**输入**: 网络拓扑, 边的代价

**输出**: 汇集树(sink tree), 就是单源节点到其他所有节点最优路径形成的树, 路由选择算法是为所有的节点找到自己的汇集树, 一个节点的汇集树不一定是另一个节点的汇集树

**路由选择原则**

- 正确性
- 简单性: 没有必要为了最优解进行复杂计算
- 健壮性: 可以适应网络拓扑的变化
- 稳定性
- 公平性
- 最有性: 没有必要为了结果最优耗费大量代价

**路由选择算法**: 

可以分为有全局算法和分布式算法

- 全局式算法: 拥有上帝视角, 可以看到所有边的代价, 直接算出最优路径
- 分布式算法: 我只知道自己邻接节点的信息, 通过相互通告计算到目标节点的最短路径与转发方式(转发到哪个邻居)

可以分为静态算法与动态算法

#### Link State(LS) 算法

实际上就是dijkstra算法

- 通过各种渠道(泛洪等)获得**整个网络**的拓扑与代价
  - 发现相邻节点(发送Hello分组)获取对方网络地址
  - 测量相邻节点之间的代价(延迟, 开销...)
  - 每个节点组装一个LS分组描述这个节点到其他路由器的代价
  - 将LS分组泛洪到周边路由器(为了防止泛洪造成的网络风暴: LS分组有TTL, LS分组有版本号, 如果收到老版本的LS分组就不做处理), 同时这个泛洪是有确认的, 收到LS分组后要返回接受成功响应
- 使用LS路由算法计算本节点到其他节点的最优路径(汇集树)
- 按照路由表进行转发
- 应用: OSPF协议, IS-IS协议

#### Distance Vector Routing (DV)距离矢量路由算法

- 基本思想: 

  每个节点维护一张路由表, 包含

  | To(目标IP与掩码) | Next(下一跳转出端口) | Cost(到目标的代价, 非到下一跳代价) |
  | ---------------- | -------------------- | ---------------------------------- |
  | ...              | ...                  | ...                                |

  相邻两个邻居互相交换距离**矢量**

  节点收到路由表, 测量与邻居的距离**矢量**, 计算经过这个邻居到目标节点的距离矢量

  更新最小值

- 递归方程
  $$
  d_x(y) = min\left(c(x,v)+d_v(y)\right)
  $$
  其中`d_x(y)`是x到y的矢量距离, 当然, 存在`v=x`
  
- 特点

  - 好消息传的快(迭代后代价减少, 下次通告的时候会带上这个消息)
  - 坏消息传的慢(迭代后代价变大, 这个通告的结果不会影响路由表 直到TTL)

- 水平分裂算法/毒性逆转算法 (用来防止坏消息传的慢)

  有如下链的时候

  ```mermaid
  graph LR
  A --- B --- C --- D
  ```

  - AB是**邻接**的, B一定准确知道AB之间的代价
  - C向B发送通告的时候就将$d_C(A)$设置为INF, 因为$d_B(A)$比$d_C(A)$更加权威
  - C向D发送通告的时候就将$d_C(A)$的值原封不动的发给D, 因为两个值都不权威 

LS算法可以一次性算出全局路由表, 但是DV是迭代算法(异步)

**两种算法的对比**

| 类别             | LS算法   | DV算法       | 优者 | 问题                                                       |
| ---------------- | -------- | ------------ | ---- | ---------------------------------------------------------- |
| 消息复杂度       | $O(nE)$  | 局部交换     | DV   |                                                            |
| 收敛时间         | $O(n^2)$ | 缓慢         | LS   | LS存在全局震荡<br />DV依赖路由环境<br />DV存在坏消息收敛慢 |
| 健壮性(局部故障) | 无影响   | 泛洪, 收敛慢 | LS   | 见下                                                       |

局部故障时:

- LS算法会通告不正确的代价/ 节点只计算自己的汇集树/ 错误信息只会影响局部(经过他的节点)
- DV算法会通告全网不正确代价/ 错误会扩散到所有节点

### 自治系统的内部路由选择协议

#### RIP协议

- 采用DV算法
- 将跳数作为距离矢量(代价)
- 每隔30s/ 在对方请求的时候进行一次通告
- 每个通告最多包含25个目标子网
- 适合小型网络(因为只能包括25个目标子网)

**链路失效和恢复**

- 180s没有收到通告就认为路由失效
- 发现路由失效后立刻发出通告
- 使用毒性逆转算法
- 链路代价大于16就认为节点不可达

**RIP进程处理**

- RIP协议以应用进程的方式实现
- 采用**UDP**协议将通告进行周期性传播
- RIP是网络层协议, 使用了传输层的服务, 以应用实体的方式实现

#### OSPF协议

OSPF开放路径优先协议

- 使用LS算法
- 将通告通过链路在全网泛洪

OSPF通告信息中: 

- 每一个邻居路由器一个表项
- 直接采用IP数据报传输通告(而不是UDP)

**高级特性**

- 所有报文都是经过认证的, 确保了安全性
- 允许多个代价相同的路径存在(RIP只允许一个)
- 对于每一条链路允许对不同的TOS(区分服务)有多重代价矩阵(对于卫星链路采用时间做代价, 光纤的可以用跳数做代价)
- 支持单播/多播
- 在大型网络中支持层次化, 支持在大型网中分区, 区域间的传输必须借助边界路由器, 这使得泛洪的时候只在边界中进行泛洪

**层次性的OSPF路由**

- 2个级别的层次性: 本地, 骨干
  - 链路状态通告仅仅在本地区域Area范围内进行
  - 每一个节点拥有本地区域的拓扑信息:
    关于其他区域,知道去它的方向,通过区域边界路由器(最短路径)
- 区域边界路由器: “汇总(聚集)”到自己区域内网络的距离, 向其它区域边界路由器通告.
- 骨干路由器: 仅仅在骨干区域内,运行OSPF路由
- 边界路由器: 连接其它的AS’s.

还有一个ISIS路由协议几乎与OSPF一样

### IPS之间的路由选择协议

#### 层次路由

之前的RIP/OSPF是子网内部的协议, 默认所有的节点在一个子网下

**平面的路由**:

- 所有节点地位一样
- 使用LS/DV进行路由
- 所有路由器在一个平面

**节点放在一个平面路由的问题**

- `规模问题`: 数据量大导致
  - LV是$O(n^2)$算法, 无法做这么多节点的泛洪, 时间无法接受
  - DV是迭代算法, 无法收敛
- `管理问题`: 内网拓扑变透明, 无法向外隐藏, 内网无法进行定制化管理

**节点分层后**

- 在一个层次中的节点划分为多个自治区(AS)
- 区域内部节点少可以采用RIP/OSPF进行路由(甚至可以采用自定义的协议)
- 区域之间通过通告聚合暴露更少的通告, 由于使用的协议不同, 要使用新的协议在区域间进行路由
- 解决了规模问题, 管理问题

#### BGP边界网关协议

用来解决IPS之间的路由问题, 将一个个自治区域(AS)连在一起

**BGP协议为AS(自治区域)提供的方法**

- 明确: AS之间的通信都是通过两个AS的网关进行的, AS的网关也是AS的设备, 可以使用RIP/OSPF协议获得AS内部的路由信息
- `eBGP`方法: 网关收集AS的路由信息, 使用eBGP方法发送通告到其他AS网关(XXX网段的IP的信息都可以把我作为下一跳)
- `rBGP`方法: 网关获得其他AS的路由通告, 使用rBGP方法通过TCP连接告诉AS内部设备(包括内部其他网关)其他AS的路由信息(也会告诉其他AS的网关, 要去XXX网段先跳到我)
- 整体流程: 网关参与内部子网运算, 通告eBGP通告, 网关收到通告, 使用rBGP通告内部网关, 进行转发

**BGP路由信息计算方法**

- 上一层通过路由信息决定AS之间通信的"好"的路径
- 路由计算使用的是改进的路径矢量算法, 在传递矢量信息的时候传递经过的路径以判环

**BGP会话**: 两个BGP路由开机时建立BGP连接, 这是一个半永久的**TCP**连接, 用于交换报文(包含距离矢量和路径方便判环)

**BGP路径选择策略**:

在AS内部, 机器一般是一个机构的, 使用LS/DV算法直接计算网络, 目的就是相互低代价可达(更加关注性能)

在AS之间的路由一般是跨机构的路由, 不仅要考虑低代价, 还要考虑经济, 政治等因素, 路由选择可以使用以下方式优先排序

- 本地策略值
- 最短AS-PATH: 经过的AS跳数
- 最近的NEXT-HOP路由器(热土豆路由): 选择离我最近的AS发送(传热土豆的时候传给最近的人)
- 附加判据: BGP标识
- 一个前缀对应多个路径, 应该之保留一条路径

**BGP&OSPF实现跨AS通信**

- 有AB两个AS, 当A新增路由器X
- A的网关使用OSPF计算X到达网关的代价
- A的网关使用eBGP发送通告, B的网关接受通告, 使用rBGP向内网发送OSPF通告, 向内部说: 到X路由器的IP报全部发给B的网关
- B区域设备使用OSPF计算到X结果

### SDN

- 在SDN的方式下可以通告匹配不同的字段实现流量控制, 多路通信
- SDN是匹配-行动模式

**在SDN模式下**

- SDN控制器分布式运行, 向外暴露一个整体
- SDN具有通信层(南向接口), 网络状态管理层(分布式数据库), 网络应用界面层
- 路由器可以由简单的数据平面交换机进行基于硬件进行替代, 控制器通过南向接口下发流表, 控制器与数据平面交换机使用OpenFlow协议进行交换

- 网络应用(指的是实现各种功能的网络设备,例如防火墙)通过北向接口获取接口, 上报请求

**OpenFlow协议**

控制器与SDN交换机之间的协议, 使用TCP协议交换报文, 报文有

- `特性`: 控制器查询交换机特性
- `配置`: 控制器查询/配置交换机参数
- `修改状态`: 分组交换机要增删改OverFlow中的流表时要进行上报
- `packet-out`: 对于流表中没有的分组, 分组交换机上报, 控制器指定分组通过特定端口发出

简而言之就是控制器通告协议配置交换机, 下发流表, 分组交换机通过协议修改流表, 异常上报

**挑战**

- 集中式带来的可靠性问题
- 控制器性能问题
- 可信性待解决

### ICMP协议与SNMP协议

**ICMP因特网控制报文协议**

用来在主机与路由器之间进行沟通, 被广泛用于差错报告(例如TTL为0被销毁了)

ICMP协议一般被认为是IP的一部分, 但是实际上是运行在IP协议之上的, 也就是说IP数据报中包含了ICMP报文

ICMP数据报包含有类型字段与编码字段, 包含了被生成时IP报的头部与前8字节

- Ping就是向目标IP发送类型8编码0的字节

- Traceroute就是通过不断增加TTL, 接收4类型ICMP实现的(4类本身是用来实现数据链路层拥塞控制定义的, 但是现在有了TCP的拥塞控制这个就无用了)

**SNMP简单网络管理协议**

用来管理网络中网络设备的


## 链路层和局域网

一般来说, 广域网的链路层比较简单, 这章先介绍链路层基础后介绍广域网内容

链路层主要包括链路层的检错纠错, 多点接入, 链路层寻址, LAN, 可靠数据传输 

网络层是按照子网为单位进行路由, 在子网内部节点之间, 子网之间某个节点到某个节点之间的通信具体是如何通信的需要链路层协议. 可以认为网络层实现了收到一个数据包后找到要从那个口出去, 发给那个路由节点, 链路层解决的是知道要发送到某个路由节点但是如何发送的问题

链路有点到点的链路和**多点接入**的链路, 点到点的链路常用于广域网之间的通信, 例如海底光缆, 多点连接的链路常用于局域网使用一个交换介质进行管理, 例如一个无线路由器可以接入多个设备, 但是这种方式有存在发送数据的时候数据包冲突的问题

如何标识网卡是一个**编址**的问题, 找一块网卡就是一个**寻址**的问题

**术语**

- 主机, 路由器等是节点

  adapter(网卡)实现了数据链路层和物理层的功能

- 沿着通信链路相邻的节点之间的信道是链路, 分为

  - 有线/无线的链路
  - 点对点/多点的链路

- **帧**: 链路层的PDU(协议数据单元, 向下传输的信息) 实现了将网络层传来的IP报以帧的形式在链路上传播

  出现帧的意义是, 要将统一的IP报根据不同的通信链路(无线网络, 光纤网络)封装成不同的帧, 物理层根据帧发送01

### 服务

- `成帧`: 将IP数据报封装成帧(加入目标mac, 源mac...)
- `接入`: 单点或者多点链路在连接之前都要进行接入, 获取链路访问权和试用权
- `可靠数据传输`: 整体上实现可靠数据传输, 并不是所有的协议提供这种服务(例如以太网不重传, 无线链路不稳定又重传)
- `流量控制`: 发送段网卡很快, 接受端很慢, 发送端会控制流量到接受端可修改的速率
- `纠错`: 出错后修改错误/ 出错率不大时通过冗余数据纠错/ 出错后反馈出错进行重传/ 
- `全双工/半双工`: 双工指的是可收可发, 半双工指的是收发不可以同时进行, 全双工指的是手法可以同时进行

### 差错检验与纠错

**差错检验**

- D: 被保护的部分, 可以包含头部信息

  EDC: 差错检验纠正位(冗余位, 保护D)

  在数据传输后会查看D与EDC对应关系是否正确, 正确不一定传输无误, 错误一定传输出错

- 奇偶校验

  - 单Bit奇偶校验: 求和判奇偶, 只能**检查是否有单Bit错误**
  - 2维及后校验: 将数据排成矩阵, 如果存在一个节点, 他的所在的行列的单Bit奇偶校验都没有通过, 那么就说明这个节点有问题, 可以**检查和修正单Bit错误**, 无法校验对偶错误

- 累加和校验: check-sum

- **CRC循环冗余校验**

  - 模二运算: 与求余2不同, 模二运算相当于按位加, 但是不进位, 例如

    ```
    10011
    11001
    ------
    01010
    ```

    最后的结果和按位异或是一样的

    **可以将多项式的模二运算理解为二进制的除法**

  - 比特序列的表示方法

    - 使用**比特位串**表示,例如将$1001$表示为$1001$
    - 使用**多项式**表示,例如将$1001$表示为$1x^3+0x^2+0x^1+1x^0$

  - 生成多项式(一个r次方的多项式, 也就是有r+1位)

    设多项式$G$为将比特序列进行多项式表示后的结果(例如$1001$的生成多项式$G=x^3+1$)

  - **EDC需要满足**: 将D(d位)与EDC(r位)拼起来的比特串多项式表示后可以被**事先与对方约定的**的生成多项式整除, 也就是
    $$
    2^rD \oplus EDC = nG
    $$
    其中$\oplus$是异或, $2^rD$相当于D左移r位, 所以左边就是将D与EDC拼接, G是正整数

    可以转化成
    $$
    2^rD \oplus EDC \oplus EDC  = nG \oplus EDC
    $$
    因为按位异或不产生进位, 得到
    $$
    2^rD = nG \oplus EDC\\
    n EDC = 2^rD\oplus G
    $$
    我们只需要保证$2^rD\oplus G$可以被EDC整除, 所以n取几都可以, 当然取1最方便

    模二运算相当于二项式下的除法(这里可以保证能整除, 因为$2^rD$是G整数倍), 可写作以下两种形式
    $$
    \begin{align}
    EDC& = 2^rD\oplus G\\
    & = remainder\left[ \frac{2^rD}{G} \right]
    \end{align}
    $$

  - 例如D=101110, G=1001, EDC是三次多项式(四位), 求EDC
  
    ```
              101011
          __________
    1001 √ 101110000		// 后补三个0
           1001	            // 得到商为1
           _________        // 加减法用异或
             1010           // 不够算得0, 下一位
             1001           // 得到1
           _________
               1100         // 不够算得0, 下一位
               1001         // 得到1
           _________
                1010        // 得到1
                1001
           _________
                  11        // 最后的余数是11, 补0得到0011
    ```
  
    最后得到EDC = `0011`
  
- CRC性能分析: 

  - 可以检查出所有单双比特位的错误
  - 可以检查出所有小于等于r位的错误
  - 对于$r+1$位的突发错误, 检查不出的概率是$\frac{1}{2^{r-1}}$ 
  - 对于大于$r+1$位的突发错误, 检查不出的概率是$\frac{1}{2^{r}}$ 

### 多点访问协议

在共享式信道上, 共享链路不能被同时使用, 需要使用媒体访问控制(MAC)对共享链路的使用进行调度

- 特性:
  - 真正数据的传递与控制信息的传递要在同一个信道进行
  - 每个节点发送信息的时候必须以**统一的速率**R进行发送
  - n个节点同时发送的时候, n个节点的平均速率应为$\frac{R}{n}$
  - 完全分布式计算
  
- MAC的实现可以分为几种

  - 信道划分
  - 随机访问
  - 依次轮流

- 信道划分

  - TDMA时分复用

    轮流以固定时间使用信道, 如果站点无帧传输就会产生浪费(不同的人在不同的时候说话)

  - FDMA频分复用

    不同的站点被分成不同的频率(不同的人在普通的房间/频率说话)

  - CDMA码分多路复用

    所有站点在整个频段上进行传输, 使用编码将数据区分(不同的人用不同的方言说话)

  在高负载的时候效率高, 低负载效率低

- 随机访问

  - 特性

    - 想发送的时候就以R的速度全速发出, 不需要预先协调
    - 允许发生冲突
    - 有能力检测到冲突, 从冲突中恢复(重传)
    - 在低负载效率高, 高负载效率低
    - 主要有ALOHA, 时隙ALOSHA, CSMA, CSMA/CD, CSMA/CA协议

  - 时隙ALOSHA

    - 将时间分为等长时隙, 每个时隙可以发送一帧

    - 节点必须在一个时隙的开始发送帧, 所有节点时间同步

    - 如果多节点在一个时隙同时发送, 所有的节点都可以发现冲突(可以看到是因为两个数据包的能量/震幅一定是大于一个节点的,  都可以看到是因为数据包的传输是广播的, 到了对方网卡对方才校验是不是自己的数据包进行保留)

    - 通信发生**冲突后**源节点需要重新发送数据, 如果同时发送, 数据包会再次冲突, 所以**再次发送的时候**以概率$p$决定是否在这个时槽发送(如果运气不好的话可能永远没法成功发出, 没法保证延迟)

    - `优点`

      - 节点可以全速传播
      - 高度分布, 仅仅需要做时隙同步
      - 想什么时候发什么时候发(只有冲突过后才会按照概率发送)

    - `缺点`

      - 存在冲突, 造成时隙的浪费
      - 有空闲时隙
      - 一个帧会在一个时隙结束的时候传晚完, 节点在半路就可以检测到冲突, 但是要等到时隙结束后才能进行下一次的传输
      - 要求时钟同步

    - `效率`

      传输成功的时槽占总时槽的百分比的上限: 约为37%

  - 纯ALOHA

    - 数据帧什么时候形成就什么时候发出
    - 发送冲突的概率比时隙ALOHA大的多(时隙ALOHA的帧全在时隙内,要碰全碰, 要么不碰, 纯ALOHA存在帧头帧尾等多种情况的碰撞)
    - 效率: 17.5%

  - CSMA载波侦听多路访问

    - 节点监听自己所在的信道是否使用, 使用就不发了
    - 冲突仍然存在, 节点只能帧听到自己所在信道的利用信息
    - 信道越长, 传播延迟越大, 冲突可能性越大

  - CSMA/CD(应用于以太网)

    - CSMA是在发送数据之间帧听

    - CS是边发送数据边帧听, 遇到冲突停止发送

    - CSMA与CS同时工作

    - 冲突后

      - 所有监听到冲突的设备全部发送强化冲突电磁波信号(发生冲突的地方可能离源节点比较远,到达源节点的时候信号衰减到正常强度, 源节点检测不到, 所以监听到冲突的节点全部发送强化信号让其他节点发现)

      - 使用二进制指数退避算法: 

        定义k为连续发生冲突的次数, 在发送冲突后从$0 \sim 2^k-1$随机中选一个整数t, 等待5*512位时后重发, 当然, 选择到0就马上重发

    - 载荷越大, 连续碰撞次数越多, 等待时间越长

    - 效率:

      定义$T_{prop}$是两个节点最大传输延时, $T_{trans}$是最大帧传输时间
      $$
      efficient = \frac{1}{1+5\frac{T_{prop}}{T_{trans}}}
      $$
      传输延迟为0/最大帧传输时间无穷(直接成点对点了)可以使得效率比为1

    - 比ALOHA廉价, 高效, 全分布

  - CSMA/CA(应用于WLAN)

    - WLAN有基站(AP), 无线链路, 移动主机节点组成

    - 无线网络信号衰减大, 干扰情况严重, 难以做冲突检测

      在LAN中不冲突几乎相当于成功(当帧时长大于$2\tau$), 在WLAN中冲突不相当于不成功

    - CSMA: 在发送之前线帧听

    - CD: 全速发送数据, 不做冲突检测, 在监听到信道忙的时候随机一个时间发送数据, 重发直到收到ACK

    - RTS-CTS冲突避免: 可选项, 提前发送请求预约

  - 线缆接入网络

    - 用户采用共享式线缆, 用于接受互联网电视信息, 只有用户到唯一服务商和唯一服务商到用户
    - 下行信道将所有的下行数据打包, 在线缆中发送, 谁需要谁拿走自己的一部分
    - 上行信道被分割为两种时隙
      - 预约的时隙: 预约且头端允许后才可以使用
      - 竞争的时隙: 用于向上行信道预约时隙,
    - 冲突: 当用户发现头端发回的预约结果没有自己, 就说明发生了冲突, 采用类似头端退避的方式重传

- 依次轮流

  - 轮询

    - 主节点依次邀请从节点发送请求

    - 从节点比较被动

    - 轮询开销大
    - 刚刚问过的节点忽然有需求要等待较长时间
    - 单点故障后果严重 
    - 效率高

  - 令牌传递

    - 定义一个特殊的令牌帧, 令牌帧给谁谁发信息, 令牌在节点之间轮转
    - 节点需要数据的时候就取下令牌, 打标记, 在令牌后面加入数据令牌继续轮转
    - 接受节点收到令牌后取下数据, 不取消标记, 放入响应和数据, 继续轮转令牌
    - 发送节点收到令牌后手下数据, 取消标记, 轮转一个无数据令牌

    令牌转一圈数据的收发依次, 目标节点收到令牌**不能**直接重置令牌为空令牌

    **特点**

    - 分布式没有单点故障
    - 高低负载效率都好
    - 存在令牌丢失的问题, 丢失后要求分布式的指定一个设备成令牌, 比较复杂

### LANs

#### 地址与ARP

- IP是层次化的,用于子网之间的路由;  Mac用于路由平面, 用于子网内部转发

  IP数据包进行转发的时候, 在子网之间通过路由实体使用, 使用三层设备进行路由(网络层的IP), 最后在子网内部使用二层交换设备(数据链路层的Mac)进行数据交换

- Mac地址是48Bit, 12个16进制数表示的, FF-FF-FF-FF-FF-FF(48为全1)表示广播Mac

  Mac地址保证了唯一性, 可以理解Mac是身份证号, IP理解为住址

- ARP协议: 

  - 作用: 通过IP获得Mac, 数据包在子网之间转发的时候就需要将下一跳IP转化为Mac
  - 在LAN上每个IP节点都有一个ARP表
  - ARP表包括了LAN上IP与MAC的映射以及映射的TTL(映射失效时间)
  - **在同一LAN下**请求MAC的时候, 先查询ARP表. 若查询失败则向全网发送广播(FF-FF-FF-FF-FF-FF), 询问IP对应的MAC, 对应IP设备响应MAC, 将映射存入ARP表
  - **在不同LAN下**请求体先将数据发送到默认网关(DHCP获得), 网关查表决定是在子网内交换还是路由到其他子网, 网关将数据转发到对应端口, 对应端口修改源MAC, 目标MAC,重新封装帧格式(不修改IP)

#### 以太网

以太网是最主流的LAN技术

**发展**

- 以太网最初是: 

  主机节点连接到网卡, 网卡通过收发器电缆连接到收发器上, 收发器连接到同轴电缆上. 

  同轴电缆是一个铜线外部包覆着铜网, 接收器刺破铜网连接在铜线上, 连接在同轴电缆上的接收器相当于在一个总线上, 一个接收器发出电磁波其他设备都可以帧听到. 为了防止电磁波在同轴电缆两端反射, 又加上了终结器吸收到端的电磁波

  连接在同轴电缆上的主机都采用CSMA/CD在发送数据前/时进行帧听, 防止冲突

- 总线型的连接方式导致总线单点损坏, 所有设备都无法正常发送(破损处没有终结器, 破损的两边都无法工作)

  使用集线器代替同轴电缆, 集线器的端口接计算机, 集线器之间支持集联

  **集线器**的工作原理是: 接受一个端口发来的消息, 保持不变的速率发送到所有的端口.  本质上是一个物理层的中继器, 不提供冲突检测与帧缓存(都是数据链路层的东西)

  在集线器上的设备不能同时发送请求, 否则会出现冲突. 将集线器上的这些设备称为在一个碰撞域内 

  虽然加入了集线器, 但是还是相当于是总线连接的结构, 只不过在物理上看起来像星形, 单点损坏的几率小

- 集线器如果连接过多节点, 冲突发生率过大, 网络效率变低, 于是引入了交换机

  **交换机**连接到机器, 机器发送信息后交换机暂存信息, 通过数据链路层协议获取目标MAC, 找到对应主机的端口, 进行数据链路层的转发. 发送给目标机器, 就好像端口之间有一个瞬间的切换开关. **交换机连接的设备之间是支持同时的数据传输的**. 交换机工作在数据链路层, 所以每个交换机端口都有自己的MAC, 同时使用了CSMA/CD 防止缓存/发出时冲突

  由于是机器直接与交换机通信, 交换机暂存数据, 所以每个机器与交换机的对应网卡口组成一个冲突域, 相当于是点对点连接

**以太帧的结构**

网卡将IP数据报封装成以太网帧

![以太帧结构](./6-1.png)

- `preamble`: 前导码, 7Byte的重复`10101010`和1个Byte的`101010011`. 用于同步收发双方的时钟频率. 让接受端可以按照发送端的速率传输帧
- `dest address`,`source address`: 目标MAC地址, 源头MAC地址 分别为48bit, 用于接受端校验自己是不是接受者(还有可能是FF-FF-FF-FF-FF-FF的广播地址, 或者网卡开启混搭模式)
- `type`: 上层协议类型(IP/IPX...)
- `CRC`: CRC校验, 写在最后, 网卡可以一边写入data, 一边计算CRC

**以太网的服务模型**

- 无连接的: 收发双方不握手
- 不可靠的: 接收者不返回ACK/NAK, 因为以太网是跑在LAN上的, 有线信道本身传输是较为可靠的, 如果需要保证可靠性需要在上层协议中实现(例如TCP)
- 采用二进制退避的CSMA/CD的MAC协议

**以太网标准**

以太网有不同的协议

- 采用相同的MAC协议与帧结构
- 具有不同的速率
- 采取不同的物理层结构
- 有不同的物理媒介: 光纤, 同轴电缆, 双绞线

**编码**(物理层的内容了)

- 我们不能简单的将1作为上电位, 0作为下电位传输, 这样接收方无法准确进行计时, 例如`00000`直接传递5比特时下电位, 接收方也不知道是传输了几个0(存在累计误差)

- Manchester曼彻斯特编码
  - 在10Mbps网络中使用
  - 允许每一个Bit位时中间有一个信号跳变
  - 接收方与发送方进行数据同步
  - 在每一个周期(传输一个Bit的比特时)中, 想要传输1则在周期开始时设置到上电位, 在周期结束前变化到下电位,  想要传输0则在周期开始时设置到下电位, 在周期结束前变化到上电位
  - 虽然我们传输的是10Mbps的数据, 但是我们用的带宽有20Mbps(每次和传递都要变一下)
- 4b5b编码
  - 用在100Mbps中
  - 将每4Bit的数据转换为5Bit的数据传输, 增加了一位后5Bit数据排列组合结果比4Bit大一倍, 筛选一半变化明显的排列建立映射关系, 例如`0011`用`10101`表示
- 8b10b编码
  - 千兆网使用
  - 千兆以太网使用标准以太帧格式, 使用CSMA/CD技术, 效率高, 几乎不会冲突

#### 网络设备

**集线器**

- 网段(LAN segments) :可以允许一个站点发送的网络范围
  - 在一个碰撞域,同时只允许一个站点在发送
  - 如果有2个节点同时发送,则会碰撞
  - 通常拥有相同的前缀,比IP子网更详细的前缀
- 所有以hub连到一起的站点处在一个网段,处在一个碰撞域
  - 骨干hub将所有网段连到了一起
- 通过hub可扩展节点之间的最大距离
- 通过HUB,不能将10BaseT和100BaseT的网络连接到一起

**交换机**

- 链路层设备:扮演主动角色(端口执行以太网协议)
  - 对帧进行存储和转发
  - 对于到来的帧,检查帧头,根据目标MAC地址进行选择性转发
  - 当帧需要向某个(些)网段进行转发,需要使用CSMA/CD进行接入控制
  - 通常一个交换机端口一个独立网段
- 透明:主机对交换机的存在可以不关心
  - 通过交换机相联的各节点好像这些站点是直接相联的一样
  - 有MAC 地址;无IP地址
- 即插即用,自学习:
  - 交换机无需配置, 主机过自主学习知道哪些节点可达
  - 执行过滤、自学习和生成树算法防止成环
  - 当收到帧的时候记录发送方端口和MAC到映射表(转发表)中
  - 当收到帧的时候对帧进行转发, 如果不知道目标MAC的端口就**直接泛洪这个帧**
- 支持级联: 交换机可以自学习自己连接的其他交换机下的设备MAC, 级联模式下CSMA/CD显得尤为重要

**路由器**

- 路由器是三层设备, 按照IP工作
- 与交换机一样, 路由器也是存储转发设备, 不过工作层级不同
- 路由器维护路由表,执行路由算法
  - 路由算法能够避免环路,无需执行生成树算法,可以以各种拓扑构建网络
  - 对广播分组做限制
  - 不是即插即用的,配置网络地址(子网前缀)
  - 三层设备,速率低

#### VLAN

虚拟局域网, 可以按照MAC, 端口号手动定义某些设备在一个广播域内

### 链路虚拟化与数据中心网络

**MPLS多协议标记交换**

按照定义的标签来交换分组, 而不是按照目标IP进行传法

**数据中心网络**

服务器与存储器要进行高带宽, 低延迟, 高可靠性的数据传输

数据中心的流量分为内部的交流流量与向外的流量, 向外流量需要大量网关进行支撑, 向内流量则需要设计一个优秀的内部网络拓扑

数据中心网络应该支持正反向代理与负载均衡, 具有一定的等级体系与冗余线路, 当有链路断开后重新执行最小生成树算法启用部分冗余链路构成新的网络

**Web请求的流程**

1. 用户上线DHCP(调用了UDP, IP)
2. 请求URL与子网之间路由DNS, ARP, BGP
3. 子网内路由RIP, OSPF
4. Web客户端交互: TCP/HTTP

## 网络安全

**什么是网络安全**

- 私密性: 在信道中传输密文, 只有收发者知道报文内容, 截获者不知道
- 可认证性: 收发方可以确定对方的身份
- 完整性: 接收者可以确定报文在发送后没有发生改变
- 访问控制与服务可用性: 服务可以正常被使用

**网络攻击的类型**

- 窃听: 截取报文
- 插入: 插入报文
- 伪装: 在分组的源地址上写下伪装的地址
- 劫持: 将发送方或者接收方踢出, 接管连接
- 拒绝服务: 阻止服务被其他正常用户使用

### 加密原理

**密文与明文**

- 加密算法使用密钥将明文(plaintext)加密为密文(ciphertext)
- 解密算法使用密钥将密文(ciphertext)解密为明文(plaintext)

**加密算法类型**

- 对称加密体系: 收发双方使用同一个密钥进行加密和解密

- 非对称加密体系(公开密钥加密体系): 收发双方使用不同的密钥进行加密和解密

**对称加密**

- 使用密钥$K_{A-B}$对明文$m$进行映射, 得到密文$K_{A-B}(m)$, 使用密钥$K_{A-B}$对明文$K_{A-B}(m)$进行映射, 得到明文$K_{A-B}\left(K_{A-B}(m)\right)$,

  - 在通行之前要先进行密钥的传输, 当然不能在信道中明文传输, 一般进行现实中传输, 之后会介绍如何提前确认密钥

- 对称加密算法

  - **多重加密**(例如用3个不同的Key对明文进行三次加密)
  - **块加密**将一个组(例如64Bit)分块, 为每一个块单独加密
  - **分组成串**技术: 明文与前面的密文进行异或计算, 再对结果进行加密

- 加密标准

  - 对称加密标准DES: 是一个广泛用于块加密的对称加密算法, 使用56Bit对称密钥, 每64Bit一组进行加密, 是不安全的

    - 对于一个64Bit组的加密

      - 初始置换: 使用密码表指定的顺序对输入数据进行重新排列

      - 将置换后得到的64位数据分为左右32位, 右32位使用置换表扩展到48位

      - S盒压缩处理: 将48位明文与48位密钥进行异或运算得到48位结果按照顺序放入8个S-Box, SBox将数据6Bit数据采用不同的压缩表压缩成4位

        S盒子压缩的方法是: 使用指定的压缩表, 将8Bit数据的首尾两位拼起来转换为10进制得到一个新数字X, 将中间四个数二进制转10进制得到数字Y, 压缩表的X行Y列的数据就是压缩结果, 压缩表中的数字是有重复的, 保证数字$\leq 2^4-1$

      - 将S盒压缩后的结果合并, 使用P盒置换得到最终结果

      - 解密的时候使用新的算法与原来的置换表对数据进行解密

    - DES收到分组后将分组打成64Bit的小分组, 每个64Bit组在进行加密之前要先和上一个分组的密文进行异或运算

  - 对称加密标准AES: 是新的对称加密标准, 用来替换DES, 数据128Bit一组加密, 可以选择不同长度的Key

**公开密钥加密体系(非对称加密)**

- 收发双方有自己的公私钥, 公钥以证书的形式公开, 供对方下载, 私钥自己保留
- 公/私钥加密的数据无法用自己解开, 必须用另一个解, 例如用私钥匙加密的数据要用公钥解
- 发送者下载接收者的公钥, 对数据使用对方公钥加密, 收到者将密文使用私钥解密
- 公私钥之间不能相互推出
- 选择密钥算法
  - 选择大质数$p,q$
  - 计算$n=pq, z=(p-1)(q-1)$
  - 选择一个$e$与$z$互质, 选择一个$d$, 使得$de-1$可以被$z$整除
  - 得到公钥(n,e), 私钥(n,d)
- 加密与解密
  - $密文 = 明文^e mod \ n$
  - $明文 = 密文^d mod \ n$

### 认证

- AP3.1认证

  1. 发送端发送一个请求, 声称自己是自己

  2. 接受端收到后返回一个一生只用一次的数字nonce

  3. 发送端收到数字, 使用事先约定的数字进行对称加密, 将结果发回给接收端

  4. 接收端使用密钥解密数字, 检测是不是发出去的数字

- AP4.0认证流程

  1. 在AP3.1的基础上使用非对称加密

  2. 发送方发送声明
  3. 接收方返回nonce
  4. 发送方返回私钥加密的nonce
  5. 接收方要求发送方发送公钥
  6. 发送方返回公钥
  7. 接收方用公钥解密, 检查nonce

- AP5.0认证漏洞: 存在中间攻击

  A发送声明被T截获, T发送声明自己是A, 使用T自己的公私钥加密nonce, 同时向A发送一个nonce, 假装验证一下. 之后A的所有发送都会被T截获, 转发给B

  中间攻击存在的原因是B无法验证A发来公钥的正确性, 之后会介绍如何正确的拿到证书

### 报文完整性

为了保证报文的完整性, 需要对文件进行数字签名, 让设备与文件进行捆绑, 当报文被修改后可以通过数字签名验证数据的完整性, 数字签名具有: 

- 可验证性: **接收方**验证这个数字签名是谁发的
- 不可伪造性: 不能在获取到签名后伪造签名发给别人
- 不可抵赖性: 第三方可以验证签名是发送者签的

**签名方式**

- 发送方使用散列函数计算报文的摘要, 使用私钥加密摘要
- 接收方使用发送方的公钥解密数字签名验证摘要

### 密钥的分发和证书

在对称加密/AP5.0中, 我们都需要正确的获取到对方的公钥, 我们可以设置一个可信任中介, 我们认为设备与可信任中介之间一定是可信的, 不存在通信问题.

- 在对称加密算法中, 称可信任中介为KDC(Key distribution center)
- 在AP5.0中, 我们称这个中介为CA

**KDC**

1. 两个设备分别与KDC建立可信任链接(带外的方式, 比如手抄一份给KDC)
2. KDC服务器与每个注册用户分享一个对称密钥
3. A使用$K_{A-KDC}$与KDC通信, 要求获得A与B的通信密钥
4. KDC生成AB通信密钥R, 返回$K_{A-KDC}\left(R,K_{B-KDC}(A,R)\right)$
5. A解密得到AB通信的$R$与$K_{B-KDC}(A,R)$
6. A将$K_{B-KDC}(A,R)$发送给B
7. B收到后解密, 知道了与他通讯的对方是A, AB通信的密钥R

**CA**

0. 用户拿到了CA的公钥$CA^+$, 带外实现(例如安装操作系统)
1. 机器向CA服务器注册机器的公钥, CA创建一个证书, 捆绑了机器实体信息与机器的公钥
2. CA将使用私钥加密证书, 发回给机器

**信任树**

- 信任树的根是一张CA机构自己办法给自己的证书
- CA可以向其他的设备办法证书, 构造了一颗信任树

### 各个层次的安全性

**安全电子邮件**

- 第一版

  发送方可以使用对方公钥加密电子邮件, 但是非对称式加密**消耗较大**

- 第二版

  1. 发送方生成一个对称式加密密钥对电子邮件进行加密
  2. 发送方使用对方公钥加密对称式的密钥
  3. 将加密后的对称式密钥与加密后电子邮件一并发送

  做到私密性**无法做到可验证性和完整性**

- 第三版

  明文传输电子邮件, 使用摘要函数计算摘要并使用私钥加密(电子签名)

  做到了可验证与完整性, 但是无法做到私密性

- 第四版

  1. 使用**自己的私钥**计算数字签名
  2. 将明文邮件与数字签名一起使用**新生成的对称式密钥**加密
  3. 使用**对方公钥**加密对称式密钥
  4. 将2,3得到的加密后密钥与加密后的数字签名邮件一起发出

- 电子邮件加密标准: BGP

**传输层安全协议SSL**

- SSL理论上是在应用层工作

- TCP协议的报文传输是明文的, 无法做到安全性

- SSL在TCP与应用层之间, 应用层将数据发送到SSL, SSL进行加密, 发送到TCP

- SSL运行过程

  1. A向B发送TCP请求
  
  2. B将自己的公钥做成证书返回给A
  
  3. A生成用于SSL连接的主密钥, 使用B的公钥加密返回
  
  4. B收到后解密主密钥进行通信
  
  5. 实际上在通信前AB还要进行密钥导出, 生成单向数据传输的会话加密密钥与会话MAC密钥
  
     由于TCP是分片的, 我们不希望数据传输结束后再验证完整性, 所以对分组数据计算散列函数, 在上面附加了MAC用于完整性检查, 两者又被一起进行了加密传输
  
  6. 在结束SSL会话的时候也需要使用SSL发送请求, 只需要在类型字段上打上SSL终止请求的标记, 虽然这个标记是明文传输的, 但是由于有MAC字段的存在, 传输是安全的
  
- SSL记录格式: 有类型字段, 版本字段, 长度字段, 加密的数据字段, 加密的MAC字段

**网络层安全协议IPsec**

- 工作在网络层IP协议上, 传输层之下
- 分为AH与ESP协议
- 源与目标在通信之前要进行类似握手的操作, 创建一个单向的SA, SA包含协议类型/源IP/32Bit的链接ID

**数据链路层IEEE802.11 WEP encryption**

- 对每个数据报与CRC进行异或加密

### 防火墙

防火墙将内网与外网隔离开, 按照某些规则允许或者阻塞掉一些分组

内部网络通过配置防火墙的路由器连接到互联网上, 路由器对分组逐个过滤,根据规则来决定转发还是丢弃, 有: 源IP地址,目标IP地址,TCP/UDP源和目标端口,ICMP报文类别, TCP SYN 和ACK bits

**防火墙阻止的行为**

- DDoS攻击: 攻击者建立很多伪造TCP链接,对于真正用户而言已经没有资源留下了
- 阻止非法的修改 /对非授权内容的访问
- 只允许认证的用户能否访问内部网络资源 (经过认证的用户/主机集合)

**防火墙类型**

- 网络级别的分组过滤器(又分为有状态的和无状态的, 无状态的就是指定阻止/允许IP为XXX, 端口为XXX, ACK值为XXX的. 有状态指的是防火墙必须在某些条件达成例如TCP握手成功后才可以进行操作)
- 应用级别:应用程序网关

### 攻击和阻止行为

**入侵检测系统IDC**

防火墙只分析分组的头部, 不会对会话的内容进行检查, 而IDS会深入分组的内部进行分析, 同时检查分组之间的相关性, 检查特征串, 判断是不是有害分组, 用来防止端口扫描, DDoS等

**映射**

- 在攻击之前: “踩点” – 发现在网络上实现了哪些服务, 使用ping来判断哪些主机在网络上有地址, 试图顺序地在每一个端口上建立TCP连接 (看看发生了什么)
- 我们使用可以记录进入到网络中的通信流量以发现可疑的行为(IP, 端口被依次扫描)

**分组嗅探**

- 在网络中对数据包传递进行监听
- 利用ARP协议检测网卡是否处于混杂模式(ARP是广播查询, 单点回送, 混杂模式的网卡也会回送)

**IP欺骗**

- 生成一个分组, 修改源IP(例如设置成一个外网的), 源mac, 实现向外网发送信息
- 在网关设置入口过滤(例如设置出站分组的源IP是内网的)

**DDoS攻击**

- 分布式的发起拒绝服务攻击
- 在到达主机之前过滤分组
