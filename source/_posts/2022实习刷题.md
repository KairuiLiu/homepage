---
title: 2022实习刷题🔒
date: 2022-2-25 00:00:00
toc: true
hidden: true
description: 做错的面试题
password: cwl248best
categories:
  - [前端, 其他]
tags:
  - 前端
  - 笔记
---

---

### Day1

#### 笔试题

- 进程从运行状态进入就绪状态的原因可能是: 时间片用完✔ 等待某一事件 ✖(等待事件会进入阻塞状态)
  ![进程三态模型](./2022实习刷题/1-1.jpg)
  ![进程三态模型](./2022实习刷题/1-2.png)
- 在MySQL中Replace在相同的主键或者唯一键的时候相当于哪个操作: DELETE+INSERT
- 主机A与主机B已建立TCP连接，A的cwnd(拥塞窗口)大小初始值为1KB，ssthresh(阈值)为16KB，B的rwnd (接收缓存窗口)初始值为8KB，一个最大报文段为1KB，假设数据传输过程中未出现超时，经过3个RTT(3轮传输)后，且B尚未从缓存中取出任何数据时候，主机A的发送窗口大小为: 8-1-2-4=1K
- 树转二叉树: 父节点的第一个子节点作为左儿子, 其余节点做左儿子的右儿子(简便: 在所有兄弟结点之间加一连线, 对每个结点，除了保留与其第一个儿子的连线外，去掉该结点与其它孩子的连线), 例如:
  ![树与二叉树转换](./2022实习刷题/1-3.jpg)
- 平衡树旋转时机: 高度差大于1, 将中间旋转为父节点
- 以下关于JavaScript中数据类型的说法错误的是
  - 数据类型分为基本数据类型和引用数据类型[✔]
  - JavaScript一共有8种数据类型[✔: Number/ String/ Boolean/ Undefined/ Null/ Symbol/ BigInt （大整数，能够表示超过 Number 类型大小限制的整数，ES 2020新增）]
  - BigInt是可以表示任意精度整数的基本数据类型，存储于栈(stack)中[✔]
  - Object是引用数据类型，且只存储于堆(heap)中[✖]
  JS变量存储机制: 对于原始类型，数据本身是存在栈内，对于对象类型，在栈中存的只是一个堆内地址的引用。[详情](https://zhuanlan.zhihu.com/p/362219811)
  - 变量与函数提升
    - `var`提升
      ```js
      console.log(a);
      var a = 3;
      ```
      提升为
      ```js
      var a; // 将变量a的声明提升至最顶端，赋值逻辑不提升。
      console.log(a); // undefined
      a = 3; // 代码执行到原位置即执行原赋值逻辑
      ```
    - 函数提升: 函数提升只会提升函数声明，而不会提升函数表达式。
      ```js
      console.log(foo1); // [Function: foo1]
      foo1(); // foo1
      console.log(foo2); // undefined
      foo2(); // TypeError: foo2 is not a function
      function foo1 () {
          console.log("foo1");
      };
      var foo2 = function () {
          console.log("foo2");
      };
      ```
    - 函数提升要比变量提升的优先级要高一些，且不会被变量声明覆盖，但是会被变量赋值之后覆盖
  - delete运算符只能删除自由属性，不能删除继承属性
  - 求输出
    ```js
    function side(arr) {
    arr[0] = arr[2];
    }
    function func1(a, b, c = 3) {
        c = 10;
        side(arguments);
        console.log(a + b + c);
    }
    function func2(a, b, c) {
        c = 10;
        side(arguments);
        console.log(a + b + c);
    }
    func1(1, 1, 1);// 12
    func2(1, 1, 1);// 21
    ```
    一般情况下，也就是非严格模式下，函数的arguments数组里面的内容是会随着函数内赋值而变化的，而改变arguments也会改变abc的值。而为函数形参赋予初始值这个行为会强制该函数内启用严格模式，因此arguments中的c是不会随着c被赋值而改变的。故func1中，调用side会让a被赋值1，而func2中会赋值10.
  - SNMP->UDP, DHCP->UDP, POP3->TCP, SMTP-> TCP/UDP







#### 算法题

- **LeetCode-33**: [地址](https://leetcode-cn.com/problems/search-in-rotated-sorted-array/)
  考虑到数组是两段上升序列, 并保证一段严格大于另一段, 可以考虑直接进行二分, 并判断l->mid与mid->r那一段处于严格上升的序列中, 利用严格上升的一段进行转换
- **LeetCode-34**: [地址](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/submissions/)
  JS中Map构造时会进行覆盖, 于是可以使用如下方法通过
  ```ts
  function searchRange(nums: number[], target: number): number[] {
      const m1 = new Map(nums.map((d,i)=>[d,i]));
      const m2 = new Map(nums.reverse().map((d,i)=>[d,i]));
      const r = m1.has(target)?m1.get(target):-1;
      const l = m2.has(target)?m2.get(target):-1;
      if(r===-1)return [-1,-1];
      return [nums.length-l-1, r];
  }
  ```
- [剑指 Offer II 001. 整数除法](https://leetcode-cn.com/problems/xoh6Oh/)
  使用位运算倍增除数, 实现快除
  **注意: JS中`1<<n`采用msi计数, 范围为$2^{-31}\to 2^{31}-1$, `2**n`范围为正负NUMBER_MAX, 注意输入的特判**

### Day2

#### 算法

- 两数之和: 给单调数组, 求两数和为target的所有解: 双指针对撞
- 三数之和: 给单调数组, 求三数和为target的所有解: 定义三个数下标: l, m, r. 枚举l, m, r双指针对撞, 当value[l]>target/2退出
- 四数之和: 给单调数组, 求四数和为target的所有解: 数组元素排序去重(最多四个相同的), 两两枚举存map, map中的key进行两数之和
- [LeetCode-meituan-002小美的仓库整理](https://leetcode-cn.com/problems/TJZLyC/)set维护左右边界, 前缀和计算重量, map计算, map记录重量出现次数, **CPP中map的Key必须重载<, 于是可以使用`m.begin()->first/second`获取最小Key的Key与Value, `m.rbegin()->first/second`获取最大Key的Key与Value**

### Day3

#### 笔试题

- 在Linux 系统中，下列哪些操作可以把一个普通用户变为管理员？
  - su[✔]
  - passwd[✖]
  - usrchmod[✖: usrchmod命令用于修改用户id, home, 密码有效期等]
  - 修改/etc/passwd 文件[✔: 用户ID修改为0]
- vue是单向数据流，单向/双向数据绑定, react是单向数据流，单向数据绑定
- 下面可以声明数字的js代码是
  - `const a = 0xa1`[✔]
  - `const a = 076`[✔]
  - `const a = 0b21`[✖: 2进制不能出现2]
  - `const a = 7e2`[✔]
- JS中
  - 会改变数组的方法：`push()`, `pop()`, `shift()`, `unshift()`, `splice()`用于添加或删除数组中的元素。, `reverse()`, `forEach()`, `sort()`
  ```js
  const months = ['Jan', 'March', 'April', 'June'];
  months.splice(1, 0, 'Feb');
  // inserts at index 1
  console.log(months);
  // expected output: Array ["Jan", "Feb", "March", "April", "June"]

  months.splice(4, 1, 'May');
  // replaces 1 element at index 4
  console.log(months);
  // expected output: Array ["Jan", "Feb", "March", "April", "May"]
  ```
  - 不会改变数组的方法： `filter()`, `concat()`用于合并数组, `slice()`, `map()`
  ```js
  const array1 = ['a', 'b', 'c'];
  const array2 = ['d', 'e', 'f'];
  const array3 = array1.concat(array2);

  console.log(array3);
  // expected output: Array ["a", "b", "c", "d", "e", "f"]
  ```
- CSS 回流(reflow): 回流是指浏览器为了重新渲染部分或者全部的文档而重新计算文档中元素的位置和几何构造的过程。因为回流可能导致整个dom树的重新构造，所以会影响性能。
  - color	border-style
  - visibility
  - background
  - text-decoration
  - background-image
  - background-position
  - background-repeat
  - outline-color
  - outline
  - outline-style
  - border-radius
  - outline-width
  - box-shadow
  - background-size
- `/etc/networks`存路由表, 没有主机名

#### 算法题

没什么重要的

### Day4

#### 笔试题

没什么重要的

### Day5

#### 面试

https://www.nowcoder.com/discuss/836718?source_id=discuss_experience_nctrack&channel=-1

- last-child/ last-of-type
  - `.a:last-child`: 表示其父元素的最后一个子元素，且被.a，才可以生效。
  - :last-of-type表示其父元素下的每一个类型(p, div)的最后一个元素, 且被选中。
  ```html
  <div>
    <div class="q w b" >1</div>
    <div class="q w b" >2</div>
    <span class="q w a" >3</span> <-- 最后一个span 有.w 变绿
    <div class="q a" >5</div>
    <div class="w b" >4</div> <-- 最后一个div 有.w 变绿. 最后一个元素, 没有a, 变红失败. 最后一个元素, 有b, 变大.
  </div>
  <style>
    .w:last-of-type {
      background-color: #bfa;
    }
    .a:last-child {
      color: red;
    }
    .b:last-child {
      font-size: 40px;
    }
  </style>
  ```
- table的表格边距合并: `border-collapse: collapse`
  <p class="codepen" data-height="300" data-default-tab="css,result" data-slug-hash="podqZOO" data-preview="true" data-editable="true" data-user="kairuiliu" style="height: 300px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;">
    <span>See the Pen <a href="https://codepen.io/kairuiliu/pen/podqZOO">
    Untitled</a> by KairuiLiu (<a href="https://codepen.io/kairuiliu">@kairuiliu</a>)
    on <a href="https://codepen.io">CodePen</a>.</span>
  </p>
  <script async src="https://cpwebassets.codepen.io/assets/embed/ei.js"></script>
- document.readyStat: DOM操作结束

#### 算法

#### 笔试

- 以下关于哈希表的描述哪个是正确的？
  - 哈希表中的key的存放是有序的[✖]
  - 哈希表查询的时间复杂度是O(1)[✔]
- 下列哪些是IPv6过渡技术
  - 隧道技术: 网络层的首部后面追加网络层首部的通信方法，叫做隧道。提供了两个IPv6站点之间通过IPv4网络实现通讯连接，以及两个IPv4站点之间通过IPv6网络实现通讯连接的技术。
  - 地址翻译技术: 提供了IPv4网络与IPv6网络之间的互访技术。
  - 双栈技术：双栈技术是IPv4向IPv6过渡的一种有效的技术。网络中的节点同时支持IPv4和IPv6协议栈，源节点根据目的节点的不同选用不同的协议栈，而网络设备根据报文的协议类型选择不同的协议栈进行处理和转发。双栈可以在一个单一的设备上实现，也可以是一个双栈骨干网。对于双栈骨干网，其中的所有
  - 应用识别技术(✖: 应用层的识别技术)
- CSS position属性的默认取值是: static(正常的布局行为), [MDN](https://developer.mozilla.org/zh-CN/docs/Web/CSS/position)
- 执行结果
  ```js
  if ([] == false) {console.log(1);} // 1
  if ([]) {console.log(1);} // 1
  ```
  都会将两边的值转化为Number。如arr与false比较，false转化为0，而arr为空数组，也转化为0
  `Number({}) === NaN`
  `Number([]) === 0`
- 不稳的排序: 快选希堆
- TCP协议运行时阶段连接创建/ 数据传送/ 连接终止
- 与3D有关的CSS会开启GPU加速: `transform: translateZ(0)`/ `rotate3d()`
- 结果
  ```js
  (async function () {
    return new Promise((resolve, reject) => {
      console.log('11');
      setTimeout(() => {
        console.log('1');
      }, 0);
    });
  })();


  setTimeout(function () {
    console.log('2');
  }, 0);

  // 11 1 2
  ```
  立即执行函数是立即同步执行的, 不放入队列
- 下面列表中，选择器类型的优先级是递增的：
  - 类型选择器（例如，h1）和伪元素（例如，::before）
  - 类选择器 (例如，.example)，属性选择器（例如，[type="radio"]）和伪类（例如，:hover）
  - ID 选择器（例如，#example）。
- 求值
  ```js
  var a = "window";
  var test = {
    a: "test",
    getAFunc: function () {
      return function () {
        return this.a;
      };
    }
  };
  console.log(test.getAFunc()()); // window
  ```


### Day6

#### 算法

#### 笔试

- replace用法
  ```js
  s.replace(/R\.+L/g, str => {
    let len = str.length
    let halfLen = parseInt(len / 2)
    let middle = len % 2 !== 0 ? '#' : ''
    return 'R'.repeat(halfLen) + middle + 'L'.repeat(halfLen)
  })
  ```
- transform只对受控于盒模型的元素生效
- 浏览器缓存是性能优化中简单高效的一种方式，按照缓存位置划分为以下几种类型：`.service Worker`, `. Memory Cache`, `.Disk Cache`, `.Push Cache` 浏览器请求时，会按照如上的优先级顺序，进行查找缓存，都没有命中时，才会去请求网络
- iframe存在跨域问题(父子DOM获取, AJAX请求, cookie使用)
- CJS === CommonJS, ES模块化: AMD、CMD、CommonJS、UMD、ESM
- HTTP
  - HTTP/0.9：功能捡漏，只支持GET方法，只能发送HTML格式字符串。
  - HTTP/1.0：支持多种数据格式，增加POST、HEAD等方法，增加头信息，每次只能发送一个请求（无持久连接）
  - HTTP/1.1：默认持久连接、请求管道化、增加缓存处理、增加Host字段、支持断点传输分块传输等。
  - HTTP/2.0：二进制分帧、多路复用、头部压缩、服务器推送
- 可逆加密与不可逆加密
  - 不可逆: `MD5`、`SHA`、`HMAC`
  - 可逆
    - 对称: `AES`、`DES`、`3DES`、`Blowfish`、`IDEA`、`RC4`、`RC5`、`RC6`、`HS256`
    - 非对称: `RSA`、`DSA`、`ECC`、`RS256`
- JS的预编译
  - JS运行分三步: 语法分析, 预编译(局部预编译与全局预编译), 解释执行
  - 局部预编译的4个步骤：
    - 创建AO对象（Activation Object）执行期上下文。
    - 找形参和变量声明，将变量和形参名作为AO属性名，值为undefined
    - 将实参值和形参统一。
    - 在函数体里面找函数声明，值赋予函数体。
  - 全局预编译的3个步骤：
    - 创建GO对象（Global Object）全局对象。
    - 找变量声明，将变量名作为GO属性名，值为undefined
    - 查找函数声明，作为GO属性，值赋予函数体
- HTTP2 线头阻塞: 在流水线模型中, 如果请求处理时间过长会导致流水线停滞, http2的多路复用解决了这个问题

#### 面试

https://www.nowcoder.com/discuss/848775?source_id=discuss_experience_nctrack&channel=-1

- [虚拟滚动](https://juejin.cn/post/6968442492115451935)
